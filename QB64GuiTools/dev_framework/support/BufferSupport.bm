'+---------------+---------------------------------------------------+
'| ###### ###### |     .--. .         .-.                            |
'| ##  ## ##   # |     |   )|        (   ) o                         |
'| ##  ##  ##    |     |--' |--. .-.  `-.  .  .-...--.--. .-.        |
'| ######   ##   |     |  \ |  |(   )(   ) | (   ||  |  |(   )       |
'| ##      ##    |     '   `'  `-`-'  `-'-' `-`-`|'  '  `-`-'`-      |
'| ##     ##   # |                            ._.'                   |
'| ##     ###### | Sources & Documents placed under the MIT License. |
'+---------------+---------------------------------------------------+
'|                                                                   |
'| === BufferSupport.bm ===                                          |
'|                                                                   |
'| == This include file is part of the GuiTools Framework Project.   |
'| == It provides the SUBs and FUNCTIONs of the String Buffer API.   |
'|                                                                   |
'+-------------------------------------------------------------------+
'| Done by RhoSigma, R.Heyder, provided AS IS, use at your own risk. |
'| Find me in the QB64 Forum or mail to support@rhosigma-cw.net for  |
'| any questions or suggestions. Thanx for your interest in my work. |
'+-------------------------------------------------------------------+

'--- docs\doc_BufferSupport.bm\CreateBuf.html
'---------------------------------------------------------------------
FUNCTION CreateBuf%
'--- find next free handle ---
aub& = UBOUND(simplebuffer_array$)
buf& = 0: CreateBuf% = SBE_NoMoreBuffers
WHILE buf& < aub&
    IF simplebuffer_array$(buf& + 1) = "" THEN EXIT WHILE
    buf& = buf& + 106
    IF buf& >= 3473408 THEN EXIT FUNCTION '=> allow max. 32768 buffers
WEND
'--- expand array, if necessary ---
IF aub& < buf& + 105 THEN REDIM _PRESERVE simplebuffer_array$(0 TO buf& + 105)
'--- init buffer ---
simplebuffer_array$(buf& + 0) = "" '                                   => the actual buffer
simplebuffer_array$(buf& + 1) = MKL$(1) + MKL$(0) + "EolU" + MKL$(-1) '=> cursor position + buffer length + EOL mode + changed state
simplebuffer_array$(buf& + 2) = "BM|" + SPACE$(404) '                  => space for 100 +1 bookmarks
simplebuffer_array$(buf& + 3) = "FP|" + SPACE$(404) '                  => space for 100 +1 found at positions
simplebuffer_array$(buf& + 4) = "FL|" + SPACE$(404) '                  => space for 100 +1 find data lenghts
FOR idx% = 1 TO 101
    MID$(simplebuffer_array$(buf& + 2), idx% * 4, 4) = MKL$(&HCAFEBABE)
    MID$(simplebuffer_array$(buf& + 3), idx% * 4, 4) = MKL$(&HCAFEBABE)
    MID$(simplebuffer_array$(buf& + 4), idx% * 4, 4) = MKL$(&HCAFEBABE)
    simplebuffer_array$(buf& + idx% + 4) = "" '        => space for 100 +1 find data copies (5-104/105)
NEXT idx% '                                            => note the +1/105 is reserved for internal use
'--- return new handle ---
CreateBuf% = buf& \ 106
END FUNCTION

'--- docs\doc_BufferSupport.bm\DisposeBuf.html
'---------------------------------------------------------------------
SUB DisposeBuf (handle%)
'--- check handle ---
IF NOT CheckHandle%(handle%) THEN ERROR 258: DO: ERROR 17: LOOP 'invalid handle
buf& = handle% * 106
'--- erase buffer data ---
FOR idx% = 0 TO 105
    simplebuffer_array$(buf& + idx%) = ""
NEXT idx%
'--- shrink array, if possible ---
aub& = UBOUND(simplebuffer_array$)
buf& = aub& - 105
WHILE buf& > 0
    IF simplebuffer_array$(buf& + 1) <> "" THEN EXIT WHILE
    buf& = buf& - 106
WEND
IF aub& > buf& + 105 THEN REDIM _PRESERVE simplebuffer_array$(0 TO buf& + 105)
END SUB

'--- docs\doc_BufferSupport.bm\FileToBuf.html
'---------------------------------------------------------------------
FUNCTION FileToBuf% (fileSpec$)
'--- create a new buffer ---
han% = CreateBuf%
buf& = han% * 106
'--- on success, open file ---
IF han% >= 0 THEN
    ff% = FREEFILE
    OPEN fileSpec$ FOR BINARY LOCK WRITE AS ff%
    fl&& = LOF(ff%)
    '--- check file length ---
    IF fl&& > &H7FFFFFFE&& THEN
        ERROR 7 'buffer full (file too big)
        'If the program is continued from here regardless of the error,
        'then the returned buffer will be empty.
    ELSE
        '--- load file into buffer ---
        simplebuffer_array$(buf& + 0) = SPACE$(fl&&)
        GET ff%, , simplebuffer_array$(buf& + 0)
        '--- set cursor, buffer length & state ---
        MID$(simplebuffer_array$(buf& + 1), 1, 4) = MKL$(1)
        MID$(simplebuffer_array$(buf& + 1), 5, 4) = MKL$(fl&&)
        MID$(simplebuffer_array$(buf& + 1), 13, 4) = MKL$(0)
    END IF
    CLOSE ff%
END IF
'--- return new handle ---
FileToBuf% = han%
END FUNCTION

'--- docs\doc_BufferSupport.bm\BufToFile.html
'---------------------------------------------------------------------
SUB BufToFile (handle%, fileSpec$)
'--- check handle ---
IF NOT CheckHandle%(handle%) THEN ERROR 258: DO: ERROR 17: LOOP 'invalid handle
buf& = handle% * 106
'--- write file (overwrite existing !!!) ---
ff% = FREEFILE
OPEN fileSpec$ FOR OUTPUT LOCK WRITE AS ff%: CLOSE ff%
OPEN fileSpec$ FOR BINARY LOCK WRITE AS ff%
PUT ff%, , simplebuffer_array$(buf& + 0)
CLOSE ff%
'--- set state ---
MID$(simplebuffer_array$(buf& + 1), 13, 4) = MKL$(0)
END SUB

'--- docs\doc_BufferSupport.bm\CloneBuf.html
'---------------------------------------------------------------------
FUNCTION CloneBuf% (handle%)
'--- check handle ---
IF NOT CheckHandle%(handle%) THEN ERROR 258: DO: ERROR 17: LOOP 'invalid handle
buf& = handle% * 106
'--- create a new buffer ---
dhan% = CreateBuf%
dbuf& = dhan% * 106
'--- on success, copy buffer values ---
IF dhan% >= 0 THEN
    FOR idx% = 0 TO 105
        simplebuffer_array$(dbuf& + idx%) = simplebuffer_array$(buf& + idx%)
    NEXT idx%
END IF
'--- return new handle ---
CloneBuf% = dhan%
END FUNCTION

'--- docs\doc_BufferSupport.bm\BufInsertFile.html
'---------------------------------------------------------------------
SUB BufInsertFile (handle%, fileSpec$)
'--- check handle ---
IF NOT CheckHandle%(handle%) THEN ERROR 258: DO: ERROR 17: LOOP 'invalid handle
'--- load file into a temp buffer ---
than% = FileToBuf%(fileSpec$)
'--- on success, insert into buffer ---
IF than% >= 0 THEN BufInsertBuf handle%, than%
'--- dispose temp buffer ---
DisposeBuf than%
END SUB

'--- docs\doc_BufferSupport.bm\BufInsertBuf.html
'---------------------------------------------------------------------
SUB BufInsertBuf (handle%, fromHandle%)
'--- check handle ---
IF NOT CheckHandle%(handle%) THEN ERROR 258: DO: ERROR 17: LOOP 'invalid handle
IF NOT CheckHandle%(fromHandle%) THEN ERROR 258: DO: ERROR 17: LOOP 'invalid fromHandle
fbuf& = fromHandle% * 106
'--- insert data of another buffer ---
WriteBufRawData handle%, simplebuffer_array$(fbuf& + 0)
END SUB

'--- docs\doc_BufferSupport.bm\ReadBufLine.html
'---------------------------------------------------------------------
FUNCTION ReadBufLine$ (handle%)
'--- check handle ---
IF NOT CheckHandle%(handle%) THEN ERROR 258: DO: ERROR 17: LOOP 'invalid handle
buf& = handle% * 106
'--- prepare values ---
cur& = GetBufPos&(handle%)
brc$ = BufEolSeq$(handle%): brl% = LEN(brc$)
'--- find next line break ---
eol& = INSTR(cur&, simplebuffer_array$(buf& + 0), brc$)
IF eol& = 0 THEN eol& = GetBufLen&(handle%) + 1: brl% = 0
'--- read from buffer ---
ReadBufLine$ = MID$(simplebuffer_array$(buf& + 0), cur&, eol& - cur&)
MID$(simplebuffer_array$(buf& + 1), 1, 4) = MKL$(eol& + brl%)
END FUNCTION

'--- docs\doc_BufferSupport.bm\WriteBufLine.html
'---------------------------------------------------------------------
SUB WriteBufLine (handle%, text$)
'--- check handle ---
IF NOT CheckHandle%(handle%) THEN ERROR 258: DO: ERROR 17: LOOP 'invalid handle
buf& = handle% * 106
'--- prepare values ---
cur& = GetBufPos&(handle%): txl& = LEN(text$)
brc$ = BufEolSeq$(handle%): brl% = LEN(brc$)
cbl&& = GetBufLen&(handle%): chg& = txl& + brl%
'--- check buffer length ---
IF cbl&& + chg& > &H7FFFFFFE&& THEN
    ERROR 7 'buffer full (text$ too long)
    'If the program is continued from here regardless of the error,
    'then the given text was not written into the buffer.
ELSE
    '--- write into buffer ---
    simplebuffer_array$(buf& + 0) = LEFT$(simplebuffer_array$(buf& + 0), cur& - 1) + text$ + brc$ + MID$(simplebuffer_array$(buf& + 0), cur&)
    MID$(simplebuffer_array$(buf& + 1), 1, 4) = MKL$(cur& + chg&)
    MID$(simplebuffer_array$(buf& + 1), 5, 4) = MKL$(cbl&& + chg&)
    MID$(simplebuffer_array$(buf& + 1), 13, 4) = MKL$(-1)
    '--- adjust bookmarks & find positions ---
    RecalcMarks handle%, cur&, chg&
    RecalcFinds handle%, cur&, chg&
END IF
END SUB

'--- docs\doc_BufferSupport.bm\DeleteBufLine.html
'---------------------------------------------------------------------
SUB DeleteBufLine (handle%)
'--- check handle ---
IF NOT CheckHandle%(handle%) THEN ERROR 258: DO: ERROR 17: LOOP 'invalid handle
buf& = handle% * 106
'--- prepare values ---
cur& = GetBufPos&(handle%): eob& = GetBufLen&(handle%) + 1
brc$ = BufEolSeq$(handle%): brl% = LEN(brc$)
'--- find next line break ---
eol& = INSTR(cur&, simplebuffer_array$(buf& + 0), brc$)
IF eol& = 0 THEN eol& = eob&: brl% = 0
chg& = (eol& + brl%) - cur&
'--- delete from buffer ---
simplebuffer_array$(buf& + 0) = LEFT$(simplebuffer_array$(buf& + 0), cur& - 1) + MID$(simplebuffer_array$(buf& + 0), eol& + brl%)
MID$(simplebuffer_array$(buf& + 1), 5, 4) = MKL$((eob& - 1) - chg&)
IF chg& > 0 THEN MID$(simplebuffer_array$(buf& + 1), 13, 4) = MKL$(-1)
'--- adjust bookmarks & find positions ---
RecalcMarks handle%, cur&, -chg&
RecalcFinds handle%, cur&, -chg&
END SUB

'--- docs\doc_BufferSupport.bm\ReadBufRawData.html
'---------------------------------------------------------------------
FUNCTION ReadBufRawData$ (handle%, size&) 'size change intended
'--- check handle ---
IF NOT CheckHandle%(handle%) THEN ERROR 258: DO: ERROR 17: LOOP 'invalid handle
buf& = handle% * 106
'--- prepare values ---
cur& = GetBufPos&(handle%): eob& = GetBufLen&(handle%) + 1
IF size& > eob& - cur& THEN size& = eob& - cur&
'--- read from buffer ---
ReadBufRawData$ = MID$(simplebuffer_array$(buf& + 0), cur&, size&)
MID$(simplebuffer_array$(buf& + 1), 1, 4) = MKL$(cur& + size&)
END FUNCTION

'--- docs\doc_BufferSupport.bm\WriteBufRawData.html
'---------------------------------------------------------------------
SUB WriteBufRawData (handle%, rawData$)
'--- check handle ---
IF NOT CheckHandle%(handle%) THEN ERROR 258: DO: ERROR 17: LOOP 'invalid handle
buf& = handle% * 106
'--- prepare values ---
cur& = GetBufPos&(handle%): rdl& = LEN(rawData$)
cbl&& = GetBufLen&(handle%)
'--- check buffer length ---
IF cbl&& + rdl& > &H7FFFFFFE&& THEN
    ERROR 7 'buffer full (rawData$ too long)
    'If the program is continued from here regardless of the error,
    'then the given raw data were not written into the buffer.
ELSE
    '--- write into buffer ---
    simplebuffer_array$(buf& + 0) = LEFT$(simplebuffer_array$(buf& + 0), cur& - 1) + rawData$ + MID$(simplebuffer_array$(buf& + 0), cur&)
    MID$(simplebuffer_array$(buf& + 1), 1, 4) = MKL$(cur& + rdl&)
    MID$(simplebuffer_array$(buf& + 1), 5, 4) = MKL$(cbl&& + rdl&)
    IF rdl& > 0 THEN
        MID$(simplebuffer_array$(buf& + 1), 9, 4) = "EolU"
        MID$(simplebuffer_array$(buf& + 1), 13, 4) = MKL$(-1)
    END IF
    '--- adjust bookmarks & find positions ---
    RecalcMarks handle%, cur&, rdl&
    RecalcFinds handle%, cur&, rdl&
END IF
END SUB

'--- docs\doc_BufferSupport.bm\DeleteBufRawData.html
'---------------------------------------------------------------------
SUB DeleteBufRawData (handle%, size&) 'size change intended
'--- check handle ---
IF NOT CheckHandle%(handle%) THEN ERROR 258: DO: ERROR 17: LOOP 'invalid handle
buf& = handle% * 106
'--- prepare values ---
cur& = GetBufPos&(handle%): eob& = GetBufLen&(handle%) + 1
IF size& > eob& - cur& THEN size& = eob& - cur&
'--- delete from buffer ---
simplebuffer_array$(buf& + 0) = LEFT$(simplebuffer_array$(buf& + 0), cur& - 1) + MID$(simplebuffer_array$(buf& + 0), cur& + size&)
MID$(simplebuffer_array$(buf& + 1), 5, 4) = MKL$((eob& - 1) - size&)
IF size& > 0 THEN MID$(simplebuffer_array$(buf& + 1), 13, 4) = MKL$(-1)
'--- adjust bookmarks & find positions ---
RecalcMarks handle%, cur&, -size&
RecalcFinds handle%, cur&, -size&
END SUB

'--- docs\doc_BufferSupport.bm\GetBufMemData.html
'---------------------------------------------------------------------
SUB GetBufMemData (handle%, memData AS _MEM)
'--- check handle ---
IF NOT CheckHandle%(handle%) THEN ERROR 258: DO: ERROR 17: LOOP 'invalid handle
'--- get memory data size ---
DIM sizeRef AS _MEM
sizeRef = _MEM(memData.SIZE)
IF INSTR(_OS$, "[64BIT]") > 0 THEN
    _MEMGET sizeRef, sizeRef.OFFSET, size&&
ELSE
    _MEMGET sizeRef, sizeRef.OFFSET, temp&
    size&& = temp&
END IF
_MEMFREE sizeRef
'--- read amount of data from buffer ---
datStr$ = ReadBufRawData$(handle%, size&&)
'--- then copy into the memory block ---
_MEMPUT memData, memData.OFFSET, datStr$
END SUB

'--- docs\doc_BufferSupport.bm\PutBufMemData.html
'---------------------------------------------------------------------
SUB PutBufMemData (handle%, memData AS _MEM)
'--- check handle ---
IF NOT CheckHandle%(handle%) THEN ERROR 258: DO: ERROR 17: LOOP 'invalid handle
'--- get memory data size ---
DIM sizeRef AS _MEM
sizeRef = _MEM(memData.SIZE)
IF INSTR(_OS$, "[64BIT]") > 0 THEN
    _MEMGET sizeRef, sizeRef.OFFSET, size&&
ELSE
    _MEMGET sizeRef, sizeRef.OFFSET, temp&
    size&& = temp&
END IF
_MEMFREE sizeRef
'--- read out the memory block ---
datStr$ = SPACE$(size&&)
_MEMGET memData, memData.OFFSET, datStr$
'--- then write it into the buffer ---
WriteBufRawData handle%, datStr$
END SUB

'--- docs\doc_BufferSupport.bm\SetBufMark.html
'---------------------------------------------------------------------
FUNCTION SetBufMark% (handle%)
'--- check handle ---
IF NOT CheckHandle%(handle%) THEN ERROR 258: DO: ERROR 17: LOOP 'invalid handle
buf& = handle% * 106
'--- get new ID, set bookmark on success ---
fid% = FreeID%(handle%, 2)
IF fid% > 0 THEN MID$(simplebuffer_array$(buf& + 2), fid% * 4, 4) = MID$(simplebuffer_array$(buf& + 1), 1, 4)
'--- return ID ---
SetBufMark% = fid%
END FUNCTION

'--- docs\doc_BufferSupport.bm\RemoveBufMark.html
'---------------------------------------------------------------------
FUNCTION RemoveBufMark% (handle%, markID%)
'--- check handle ---
IF NOT CheckHandle%(handle%) THEN ERROR 258: DO: ERROR 17: LOOP 'invalid handle
buf& = handle% * 106
'--- check ID range ---
RemoveBufMark% = SBE_BadIDNumber
IF (markID% < 1 OR markID% > 100) AND (LEN(simplebuffer_array$(buf& + 1)) = 16) THEN EXIT FUNCTION
'--- remove (unset) bookmark ---
MID$(simplebuffer_array$(buf& + 2), markID% * 4, 4) = MKL$(&HCAFEBABE)
RemoveBufMark% = 0
END FUNCTION

'--- docs\doc_BufferSupport.bm\GetBufMark.html
'---------------------------------------------------------------------
FUNCTION GetBufMark& (handle%, markID%)
'--- check handle ---
IF NOT CheckHandle%(handle%) THEN ERROR 258: DO: ERROR 17: LOOP 'invalid handle
buf& = handle% * 106
'--- check ID range ---
GetBufMark& = SBE_BadIDNumber
IF (markID% < 1 OR markID% > 100) AND (LEN(simplebuffer_array$(buf& + 1)) = 16) THEN EXIT FUNCTION
'--- return bookmark position, if set ---
markPos& = CVL(MID$(simplebuffer_array$(buf& + 2), markID% * 4, 4))
SELECT CASE markPos&
    CASE &HCAFEBABE: GetBufMark& = SBE_UnusedID
    CASE &HDEADBEEF: GetBufMark& = SBE_ClearedID
    CASE ELSE: GetBufMark& = markPos&
END SELECT
END FUNCTION

'--- docs\doc_BufferSupport.bm\GotoBufMark.html
'---------------------------------------------------------------------
FUNCTION GotoBufMark% (handle%, markID%)
'--- check handle ---
IF NOT CheckHandle%(handle%) THEN ERROR 258: DO: ERROR 17: LOOP 'invalid handle
buf& = handle% * 106
'--- goto bookmark, if valid ---
markPos& = GetBufMark&(handle%, markID%)
IF markPos& > 0 THEN
    MID$(simplebuffer_array$(buf& + 1), 1, 4) = MKL$(markPos&)
    GotoBufMark% = 0
ELSE
    GotoBufMark% = markPos&
END IF
END FUNCTION

'--- docs\doc_BufferSupport.bm\SetBufFind.html
'---------------------------------------------------------------------
FUNCTION SetBufFind% (handle%, find$)
'--- check handle ---
IF NOT CheckHandle%(handle%) THEN ERROR 258: DO: ERROR 17: LOOP 'invalid handle
buf& = handle% * 106
'--- check search criteria ---
SetBufFind% = SBE_EmptyFind: IF find$ = "" THEN EXIT FUNCTION
'--- get new ID, set find data on success ---
fid% = FreeID%(handle%, 4)
IF fid% > 0 THEN
    MID$(simplebuffer_array$(buf& + 4), fid% * 4, 4) = MKL$(LEN(find$))
    simplebuffer_array$(buf& + fid% + 4) = find$
END IF
'--- return ID ---
SetBufFind% = fid%
END FUNCTION

'--- docs\doc_BufferSupport.bm\RemoveBufFind.html
'---------------------------------------------------------------------
FUNCTION RemoveBufFind% (handle%, findID%)
'--- check handle ---
IF NOT CheckHandle%(handle%) THEN ERROR 258: DO: ERROR 17: LOOP 'invalid handle
buf& = handle% * 106
'--- check ID range ---
RemoveBufFind% = SBE_BadIDNumber
IF (findID% < 1 OR findID% > 100) AND (LEN(simplebuffer_array$(buf& + 1)) = 16) THEN EXIT FUNCTION
'--- remove find data ---
MID$(simplebuffer_array$(buf& + 3), findID% * 4, 4) = MKL$(&HCAFEBABE)
MID$(simplebuffer_array$(buf& + 4), findID% * 4, 4) = MKL$(&HCAFEBABE)
simplebuffer_array$(buf& + findID% + 4) = ""
RemoveBufFind% = 0
END FUNCTION

'--- docs\doc_BufferSupport.bm\FindBufFR.html
'---------------------------------------------------------------------
FUNCTION FindBufFwd& (handle%, findID%, method%, treat%)
'--- check handle ---
IF NOT CheckHandle%(handle%) THEN ERROR 258: DO: ERROR 17: LOOP 'invalid handle
buf& = handle% * 106
'--- check ID range ---
FindBufFwd& = SBE_BadIDNumber
IF (findID% < 1 OR findID% > 100) AND (LEN(simplebuffer_array$(buf& + 1)) = 16) THEN EXIT FUNCTION
'--- prepare & check values ---
cPos& = GetBufPos&(handle%): eob& = GetBufLen&(handle%) + 1
fPos& = CVL(MID$(simplebuffer_array$(buf& + 3), findID% * 4, 4))
fLen& = CVL(MID$(simplebuffer_array$(buf& + 4), findID% * 4, 4))
IF fPos& > 0 AND fPos& < eob& AND cPos& = fPos& THEN cPos& = cPos& + 1
FindBufFwd& = SBE_UnusedID: IF fLen& = &HCAFEBABE THEN EXIT FUNCTION
'--- perform forward search ---
IF treat% = 0 THEN
    find$ = simplebuffer_array$(buf& + findID% + 4)
    WHILE cPos& < eob&
        SELECT CASE method%
            CASE IS < 0: IF INSTR(find$, MID$(simplebuffer_array$(buf& + 0), cPos&, 1)) = 0 THEN EXIT WHILE
            CASE IS > 0: IF INSTR(find$, MID$(simplebuffer_array$(buf& + 0), cPos&, 1)) > 0 THEN EXIT WHILE
            CASE ELSE: IF MID$(simplebuffer_array$(buf& + 0), cPos&, fLen&) = find$ THEN EXIT WHILE
        END SELECT
        cPos& = cPos& + 1
    WEND
ELSE
    temp$ = UCASE$(simplebuffer_array$(buf& + 0))
    find$ = UCASE$(simplebuffer_array$(buf& + findID% + 4))
    WHILE cPos& < eob&
        SELECT CASE method%
            CASE IS < 0: IF INSTR(find$, MID$(temp$, cPos&, 1)) = 0 THEN EXIT WHILE
            CASE IS > 0: IF INSTR(find$, MID$(temp$, cPos&, 1)) > 0 THEN EXIT WHILE
            CASE ELSE: IF MID$(temp$, cPos&, fLen&) = find$ THEN EXIT WHILE
        END SELECT
        cPos& = cPos& + 1
    WEND
END IF
'--- set & return result ---
IF cPos& < eob& THEN MID$(simplebuffer_array$(buf& + 1), 1, 4) = MKL$(cPos&)
MID$(simplebuffer_array$(buf& + 3), findID% * 4, 4) = MKL$(cPos&)
FindBufFwd& = -(cPos& * (NOT cPos& = eob&))
END FUNCTION

'--- docs\doc_BufferSupport.bm\FindBufFR.html
'---------------------------------------------------------------------
FUNCTION FindBufRev& (handle%, findID%, method%, treat%)
'--- check handle ---
IF NOT CheckHandle%(handle%) THEN ERROR 258: DO: ERROR 17: LOOP 'invalid handle
buf& = handle% * 106
'--- check ID range ---
FindBufRev& = SBE_BadIDNumber
IF (findID% < 1 OR findID% > 100) AND (LEN(simplebuffer_array$(buf& + 1)) = 16) THEN EXIT FUNCTION
'--- prepare & check values ---
cPos& = GetBufPos&(handle%): eob& = GetBufLen&(handle%) + 1
fPos& = CVL(MID$(simplebuffer_array$(buf& + 3), findID% * 4, 4))
fLen& = CVL(MID$(simplebuffer_array$(buf& + 4), findID% * 4, 4))
IF fPos& > 0 AND fPos& < eob& AND cPos& = fPos& THEN cPos& = cPos& - 1
FindBufRev& = SBE_UnusedID: IF fLen& = &HCAFEBABE THEN EXIT FUNCTION
'--- perform reverse search ---
IF treat% = 0 THEN
    find$ = simplebuffer_array$(buf& + findID% + 4)
    WHILE cPos& > 0
        SELECT CASE method%
            CASE IS < 0: IF INSTR(find$, MID$(simplebuffer_array$(buf& + 0), cPos&, 1)) = 0 THEN EXIT WHILE
            CASE IS > 0: IF INSTR(find$, MID$(simplebuffer_array$(buf& + 0), cPos&, 1)) > 0 THEN EXIT WHILE
            CASE ELSE: IF MID$(simplebuffer_array$(buf& + 0), cPos&, fLen&) = find$ THEN EXIT WHILE
        END SELECT
        cPos& = cPos& - 1
    WEND
ELSE
    temp$ = UCASE$(simplebuffer_array$(buf& + 0))
    find$ = UCASE$(simplebuffer_array$(buf& + findID% + 4))
    WHILE cPos& > 0
        SELECT CASE method%
            CASE IS < 0: IF INSTR(find$, MID$(temp$, cPos&, 1)) = 0 THEN EXIT WHILE
            CASE IS > 0: IF INSTR(find$, MID$(temp$, cPos&, 1)) > 0 THEN EXIT WHILE
            CASE ELSE: IF MID$(temp$, cPos&, fLen&) = find$ THEN EXIT WHILE
        END SELECT
        cPos& = cPos& - 1
    WEND
END IF
'--- set & return result ---
IF cPos& > 0 THEN MID$(simplebuffer_array$(buf& + 1), 1, 4) = MKL$(cPos&)
MID$(simplebuffer_array$(buf& + 3), findID% * 4, 4) = MKL$(cPos&)
FindBufRev& = cPos&
END FUNCTION

'--- docs\doc_BufferSupport.bm\CopyBufBlock.html
'---------------------------------------------------------------------
FUNCTION CopyBufBlock% (handle%, bound&)
'--- check handle ---
IF NOT CheckHandle%(handle%) THEN ERROR 258: DO: ERROR 17: LOOP 'invalid handle
buf& = handle% * 106
'--- get & check positions ---
CopyBufBlock% = SBE_OutOfBounds
IF bound& < 1 OR bound& > GetBufLen&(handle%) + 1 THEN EXIT FUNCTION
sPo& = bound&: ePo& = GetBufPos&(handle%)
IF ePo& < sPo& THEN SWAP sPo&, ePo&
'--- copy block to clip ---
_CLIPBOARD$ = MID$(simplebuffer_array$(buf& + 0), sPo&, ePo& - sPo&)
CopyBufBlock% = 0
END FUNCTION

'--- docs\doc_BufferSupport.bm\CutBufBlock.html
'---------------------------------------------------------------------
FUNCTION CutBufBlock% (handle%, bound&)
'--- check handle ---
IF NOT CheckHandle%(handle%) THEN ERROR 258: DO: ERROR 17: LOOP 'invalid handle
buf& = handle% * 106
'--- get & check positions ---
CutBufBlock% = SBE_OutOfBounds
IF bound& < 1 OR bound& > GetBufLen&(handle%) + 1 THEN EXIT FUNCTION
sPo& = bound&: ePo& = GetBufPos&(handle%)
IF ePo& < sPo& THEN SWAP sPo&, ePo&
'--- copy block to clip ---
_CLIPBOARD$ = MID$(simplebuffer_array$(buf& + 0), sPo&, ePo& - sPo&)
'--- then delete block ---
old& = SeekBuf&(handle%, sPo&, SBM_PosRestore)
DeleteBufRawData handle%, ePo& - sPo&
CutBufBlock% = 0
END FUNCTION

'--- docs\doc_BufferSupport.bm\PasteBufBlock.html
'---------------------------------------------------------------------
FUNCTION PasteBufBlock% (handle%, bound&)
'--- check handle ---
IF NOT CheckHandle%(handle%) THEN ERROR 258: DO: ERROR 17: LOOP 'invalid handle
'--- replace check ---
IF bound& <> 0 THEN
    '--- get & check positions ---
    PasteBufBlock% = SBE_OutOfBounds
    IF bound& < 1 OR bound& > GetBufLen&(handle%) + 1 THEN EXIT FUNCTION
    sPo& = bound&: ePo& = GetBufPos&(handle%)
    IF ePo& < sPo& THEN SWAP sPo&, ePo&
    '--- delete old block ---
    old& = SeekBuf&(handle%, sPo&, SBM_PosRestore)
    DeleteBufRawData handle%, ePo& - sPo&
END IF
'--- finally paste block from clip ---
WriteBufRawData handle%, _CLIPBOARD$
PasteBufBlock% = 0
END FUNCTION

'--- docs\doc_BufferSupport.bm\SeekBuf.html
'---------------------------------------------------------------------
FUNCTION SeekBuf& (handle%, displace&, mode%)
'--- check handle ---
IF NOT CheckHandle%(handle%) THEN ERROR 258: DO: ERROR 17: LOOP 'invalid handle
buf& = handle% * 106
'--- prepare values ---
cur& = GetBufPos&(handle%): eob& = GetBufLen&(handle%) + 1
brc$ = BufEolSeq$(handle%): brl% = LEN(brc$)
'--- select origin ---
SELECT CASE mode%
    CASE SBM_PosRestore: origin& = 0
    CASE SBM_BufStart: origin& = 1
    CASE SBM_BufCurrent: origin& = cur&
    CASE SBM_BufEnd: origin& = eob&
    CASE SBM_LineStart
        origin& = cur&
        IF cur& > 1 AND cur& < eob& THEN
            IF brl% = 2 AND ASC(simplebuffer_array$(buf& + 0), cur& - 1) = 13 AND ASC(simplebuffer_array$(buf& + 0), cur&) = 10 THEN
                origin& = cur& - 1
            END IF
        END IF
        WHILE origin& > 1
            IF MID$(simplebuffer_array$(buf& + 0), origin& - 1, brl%) = brc$ THEN
                IF brl% = 2 THEN origin& = origin& + 1
                EXIT WHILE
            END IF
            origin& = origin& - 1
        WEND
    CASE SBM_LineEnd
        origin& = cur&
        IF cur& > 1 AND cur& < eob& THEN
            IF brl% = 2 AND ASC(simplebuffer_array$(buf& + 0), cur& - 1) = 13 AND ASC(simplebuffer_array$(buf& + 0), cur&) = 10 THEN
                origin& = cur& - 1
            END IF
        END IF
        origin& = INSTR(origin&, simplebuffer_array$(buf& + 0), brc$)
        IF origin& = 0 THEN origin& = eob&
    CASE IS > 0 'bookmarks mode
        origin& = GetBufMark&(handle%, mode%)
        IF origin& < 0 THEN SeekBuf& = origin&: EXIT FUNCTION
    CASE ELSE
        SeekBuf& = SBE_UnknownMode
        EXIT FUNCTION
END SELECT
'--- seek to new position ---
newPos& = origin& + displace&
IF newPos& < 1 OR newPos& > eob& THEN
    SeekBuf& = SBE_OutOfBounds
ELSE
    MID$(simplebuffer_array$(buf& + 1), 1, 4) = MKL$(newPos&)
    SeekBuf& = cur&
END IF
END FUNCTION

'--- docs\doc_BufferSupport.bm\GetBufPos.html
'---------------------------------------------------------------------
FUNCTION GetBufPos& (handle%)
'--- check handle ---
IF NOT CheckHandle%(handle%) THEN ERROR 258: DO: ERROR 17: LOOP 'invalid handle
buf& = handle% * 106
'--- return cursor position in buffer ---
GetBufPos& = CVL(MID$(simplebuffer_array$(buf& + 1), 1, 4))
END FUNCTION

'--- docs\doc_BufferSupport.bm\GetBufLen.html
'---------------------------------------------------------------------
FUNCTION GetBufLen& (handle%)
'--- check handle ---
IF NOT CheckHandle%(handle%) THEN ERROR 258: DO: ERROR 17: LOOP 'invalid handle
buf& = handle% * 106
'--- return actual buffer length ---
GetBufLen& = CVL(MID$(simplebuffer_array$(buf& + 1), 5, 4))
END FUNCTION

'--- docs\doc_BufferSupport.bm\EndOfBuf.html
'---------------------------------------------------------------------
FUNCTION EndOfBuf% (handle%)
'--- check handle ---
IF NOT CheckHandle%(handle%) THEN ERROR 258: DO: ERROR 17: LOOP 'invalid handle
'--- return EndOfBuffer condition ---
EndOfBuf% = (GetBufPos&(handle%) > GetBufLen&(handle%))
END FUNCTION

'--- docs\doc_BufferSupport.bm\IsBufChanged.html
'---------------------------------------------------------------------
FUNCTION IsBufChanged% (handle%)
'--- check handle ---
IF NOT CheckHandle%(handle%) THEN ERROR 258: DO: ERROR 17: LOOP 'invalid handle
buf& = handle% * 106
'--- return BufChanged condition ---
IsBufChanged% = CVL(MID$(simplebuffer_array$(buf& + 1), 13, 4))
END FUNCTION

'--- docs\doc_BufferSupport.bm\BufEolSeq.html
'---------------------------------------------------------------------
FUNCTION BufEolSeq$ (handle%)
'--- check handle ---
IF NOT CheckHandle%(handle%) THEN ERROR 258: DO: ERROR 17: LOOP 'invalid handle
buf& = handle% * 106
'--- return buffer specific EndOfLine sequence ---
SELECT CASE MID$(simplebuffer_array$(buf& + 1), 9, 4)
    CASE "EolU", "EolN" 'OS native mode
        BufEolSeq$ = CHR$(13) + CHR$(10) 'default is Windows
        IF INSTR(_OS$, "[LINUX]") > 0 THEN BufEolSeq$ = CHR$(10) 'true for MacOSX too
    CASE "EolL" 'forced Linux/MacOSX
        BufEolSeq$ = CHR$(10)
    CASE "EolW" 'forced Windows
        BufEolSeq$ = CHR$(13) + CHR$(10)
END SELECT
END FUNCTION

'--- docs\doc_BufferSupport.bm\ConvBufToAnyEol.html
'---------------------------------------------------------------------
SUB ConvBufToNativeEol (handle%)
'--- check handle ---
IF NOT CheckHandle%(handle%) THEN ERROR 258: DO: ERROR 17: LOOP 'invalid handle
buf& = handle% * 106
'--- convert buffer to OS native EndOfLine sequence ---
IF INSTR(_OS$, "[LINUX]") > 0 THEN 'true for MacOSX too
    ConvBufToLnxMacEol handle%
ELSE
    ConvBufToWinEol handle%
END IF
MID$(simplebuffer_array$(buf& + 1), 9, 4) = "EolN"
END SUB

'--- docs\doc_BufferSupport.bm\ConvBufToAnyEol.html
'---------------------------------------------------------------------
SUB ConvBufToLnxMacEol (handle%)
'--- check handle ---
IF NOT CheckHandle%(handle%) THEN ERROR 258: DO: ERROR 17: LOOP 'invalid handle
buf& = handle% * 106
'--- check current EndOfLine sequence ---
IF MID$(simplebuffer_array$(buf& + 1), 9, 4) = "EolL" THEN EXIT SUB
IF MID$(simplebuffer_array$(buf& + 1), 9, 4) = "EolN" AND LEN(BufEolSeq$(handle%)) = 1 THEN EXIT SUB
'--- prepare values ---
simplebuffer_array$(buf& + 1) = simplebuffer_array$(buf& + 1) + CHR$(16)
IF MID$(simplebuffer_array$(buf& + 0), GetBufPos&(handle%), 2) = CHR$(13) + CHR$(10) THEN
    res& = SeekBuf&(handle%, 1, SBM_BufCurrent)
END IF
MID$(simplebuffer_array$(buf& + 2), 101 * 4, 4) = MID$(simplebuffer_array$(buf& + 1), 1, 4) 'SetBufMark 101
MID$(simplebuffer_array$(buf& + 4), 101 * 4, 4) = MKL$(2): simplebuffer_array$(buf& + 101 + 4) = CHR$(13) + CHR$(10) 'SetBufFind 101
'--- search & convert ---
res& = SeekBuf&(handle%, 0, SBM_BufStart)
DO
    po& = FindBufFwd&(handle%, 101, SBF_FullData, SBF_AsWritten)
    IF po& > 0 THEN DeleteBufRawData handle%, 1
LOOP UNTIL po& = 0
MID$(simplebuffer_array$(buf& + 1), 9, 4) = "EolL"
'--- restore old position & cleanup ---
res& = SeekBuf&(handle%, 0, 101)
res& = RemoveBufFind%(handle%, 101)
res& = RemoveBufMark%(handle%, 101)
simplebuffer_array$(buf& + 1) = LEFT$(simplebuffer_array$(buf& + 1), 16)
END SUB

'--- docs\doc_BufferSupport.bm\ConvBufToAnyEol.html
'---------------------------------------------------------------------
SUB ConvBufToWinEol (handle%)
'--- check handle ---
IF NOT CheckHandle%(handle%) THEN ERROR 258: DO: ERROR 17: LOOP 'invalid handle
buf& = handle% * 106
'--- check current EndOfLine sequence ---
IF MID$(simplebuffer_array$(buf& + 1), 9, 4) = "EolW" THEN EXIT SUB
IF MID$(simplebuffer_array$(buf& + 1), 9, 4) = "EolN" AND LEN(BufEolSeq$(handle%)) = 2 THEN EXIT SUB
IF MID$(simplebuffer_array$(buf& + 1), 9, 4) = "EolU" THEN ConvBufToLnxMacEol handle% 'safety measure
'--- prepare values ---
simplebuffer_array$(buf& + 1) = simplebuffer_array$(buf& + 1) + CHR$(16)
MID$(simplebuffer_array$(buf& + 2), 101 * 4, 4) = MID$(simplebuffer_array$(buf& + 1), 1, 4) 'SetBufMark 101
MID$(simplebuffer_array$(buf& + 4), 101 * 4, 4) = MKL$(1): simplebuffer_array$(buf& + 101 + 4) = CHR$(10) 'SetBufFind 101
'--- search & convert ---
res& = SeekBuf&(handle%, 0, SBM_BufStart)
DO
    po& = FindBufFwd&(handle%, 101, SBF_FullData, SBF_AsWritten)
    IF po& > 0 THEN WriteBufRawData handle%, CHR$(13)
LOOP UNTIL po& = 0
MID$(simplebuffer_array$(buf& + 1), 9, 4) = "EolW"
'--- restore old position & cleanup ---
res& = SeekBuf&(handle%, 0, 101)
IF MID$(simplebuffer_array$(buf& + 0), GetBufPos&(handle%), 1) = CHR$(10) THEN
    res& = SeekBuf&(handle%, 0, SBM_LineEnd)
END IF
res& = RemoveBufFind%(handle%, 101)
res& = RemoveBufMark%(handle%, 101)
simplebuffer_array$(buf& + 1) = LEFT$(simplebuffer_array$(buf& + 1), 16)
END SUB

'--- undocumented - for internal use only
'---------------------------------------------------------------------
FUNCTION CheckHandle% (handle%)
'--- check handle ---
buf& = handle% * 106: CheckHandle% = -1
IF buf& < 0 OR buf& > UBOUND(simplebuffer_array$) THEN CheckHandle% = 0
IF simplebuffer_array$(buf& + 1) = "" THEN CheckHandle% = 0
END FUNCTION

'--- undocumented - for internal use only
'---------------------------------------------------------------------
FUNCTION FreeID% (handle%, slot%)
'--- find a free ID ---
buf& = handle% * 106: FreeID% = SBE_NoMoreIDs
FOR idx% = 1 TO 100
    IF CVL(MID$(simplebuffer_array$(buf& + slot%), idx% * 4, 4)) = &HCAFEBABE THEN
        FreeID% = idx%: EXIT FOR
    END IF
NEXT idx%
END FUNCTION

'--- undocumented - for internal use only
'---------------------------------------------------------------------
SUB RecalcMarks (handle%, bufPos&, change&)
'--- check special case (no change) ---
IF change& = 0 THEN EXIT SUB
'--- recalc all used bookmarks ---
buf& = handle% * 106
FOR idx% = 1 TO 101
    mark& = CVL(MID$(simplebuffer_array$(buf& + 2), idx% * 4, 4))
    IF mark& <> &HCAFEBABE AND mark& <> &HDEADBEEF THEN
        SELECT CASE change&
            CASE IS > 0
                IF bufPos& <= mark& THEN mark& = mark& + change&
            CASE IS < 0
                IF bufPos& < mark& THEN
                    absChg& = ABS(change&)
                    IF absChg& <= (mark& - bufPos&) THEN
                        mark& = mark& - absChg&
                    ELSE
                        mark& = &HDEADBEEF
                    END IF
                ELSEIF bufPos& = mark& THEN
                    mark& = &HDEADBEEF
                END IF
        END SELECT
        MID$(simplebuffer_array$(buf& + 2), idx% * 4, 4) = MKL$(mark&)
    END IF
NEXT idx%
END SUB

'--- undocumented - for internal use only
'---------------------------------------------------------------------
SUB RecalcFinds (handle%, bufPos&, change&)
'--- check special case (no change) ---
IF change& = 0 THEN EXIT SUB
'--- recalc all used found at positions ---
buf& = handle% * 106
FOR idx% = 1 TO 101
    found& = CVL(MID$(simplebuffer_array$(buf& + 3), idx% * 4, 4))
    length& = CVL(MID$(simplebuffer_array$(buf& + 4), idx% * 4, 4))
    IF found& <> &HCAFEBABE AND found& <> &HDEADBEEF THEN
        SELECT CASE change&
            CASE IS > 0
                IF bufPos& <= found& THEN
                    found& = found& + change&
                ELSEIF bufPos& > found& AND bufPos& < (found& + length&) THEN
                    found& = &HDEADBEEF
                END IF
            CASE IS < 0
                IF bufPos& < found& THEN
                    absChg& = ABS(change&)
                    IF absChg& <= (found& - bufPos&) THEN
                        found& = found& - absChg&
                    ELSE
                        found& = &HDEADBEEF
                    END IF
                ELSEIF bufPos& >= found& AND bufPos& < (found& + length&) THEN
                    found& = &HDEADBEEF
                END IF
        END SELECT
        MID$(simplebuffer_array$(buf& + 3), idx% * 4, 4) = MKL$(found&)
    END IF
NEXT idx%
END SUB

