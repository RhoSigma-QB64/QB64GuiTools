'+---------------+---------------------------------------------------+
'| ###### ###### |     .--. .         .-.                            |
'| ##  ## ##   # |     |   )|        (   ) o                         |
'| ##  ##  ##    |     |--' |--. .-.  `-.  .  .-...--.--. .-.        |
'| ######   ##   |     |  \ |  |(   )(   ) | (   ||  |  |(   )       |
'| ##      ##    |     '   `'  `-`-'  `-'-' `-`-`|'  '  `-`-'`-      |
'| ##     ##   # |                            ._.'                   |
'| ##     ###### | Sources & Documents placed under the MIT License. |
'+---------------+---------------------------------------------------+
'|                                                                   |
'| === GuiAppFrame.bm ===                                            |
'|                                                                   |
'| == This include file is part of the GuiTools Framework Project.   |
'| == It provides some useful SUBs and FUNCTIONs for common use.     |
'|                                                                   |
'+-------------------------------------------------------------------+
'| Done by RhoSigma, R.Heyder, provided AS IS, use at your own risk. |
'| Find me in the QB64 Forum or mail to support@rhosigma-cw.net for  |
'| any questions or suggestions. Thanx for your interest in my work. |
'+-------------------------------------------------------------------+

'--- docs\doc_GuiAppframe.bm\MessageBox.html
'---------------------------------------------------------------------
FUNCTION MessageBox$ (winIcon$, winTitle$, bodyText$, buttonText$)
MessageBox$ = ""
IF winTitle$ <> "*** RhoSigma-MessageBox-HandlerCall ***" THEN
    '--- MessageBox Setup Block ---
    iBodyText$ = bodyText$ + " "
    iButtonText$ = buttonText$ + " "
    IF LTRIM$(RTRIM$(iBodyText$)) = "" THEN
        iBodyText$ = "No message specified !! "
        iButtonText$ = "Oops! "
    END IF
    IF LTRIM$(RTRIM$(iButtonText$)) = "" OR INSTR(iButtonText$, "}") = LEN(iButtonText$) - 1 THEN iButtonText$ = iButtonText$ + "Got It! "
    temp% = 0: txte% = 0: isfl% = 0
    txtn% = 0: butn% = 0
    txtw% = 0: butw% = 0
    tl% = LEN(iBodyText$)
    FOR i% = 1 TO tl%
        c$ = MID$(iBodyText$, i%, 1)
        IF c$ = "|" OR c$ = "~" OR i% = tl% THEN
            IF temp% = 0 THEN txte% = txte% + 1
            IF temp% > txtw% THEN txtw% = temp%
            temp% = 0
            txtn% = txtn% + 1
        ELSE
            temp% = temp% + 8
        END IF
    NEXT i%
    txtw% = txtw% + 4 'add for frame thickness
    bl% = LEN(iButtonText$)
    FOR i% = 1 TO bl%
        c$ = MID$(iButtonText$, i%, 1)
        IF c$ = "{" THEN
            isfl% = -1
            temp% = temp% + 26
            i% = INSTR(i% + 1, iButtonText$, "}") + 1
            c$ = MID$(iButtonText$, i%, 1)
        END IF
        IF c$ = "|" OR i% = bl% THEN
            IF temp% > butw% THEN butw% = temp%
            temp% = 0
            butn% = butn% + 1
        ELSE
            temp% = temp% + 8
        END IF
    NEXT i%
    butw% = butw% + 10 'inner button spacing
    butw% = ((butw% + 7) AND -8) 'round to next multiple of 8

    ospc% = 8 'nominal object spacing
    txtl% = (2 * ospc%): txtt% = (2 * ospc%): txth% = 20
    fral% = txtl% - ospc%: frat% = txtt% - ospc%: fraw% = txtw% + (2 * ospc%): frah% = (txtn% * txth%) - (txte% * INT(txth% / 3)) + (2 * ospc%)
    butl% = fral%: butt% = frat% + frah% + ospc%
    IF isfl% THEN buth% = 31: ELSE buth% = 26
    temp% = butn% * butw% 'extend width to # of buttons
    IF butn% > 1 THEN temp% = temp% + ((butn% - 1) * ospc%) '+ inter button spacing
    IF temp% > fraw% THEN
        diff% = temp% - fraw%
        fraw% = temp%
        txtl% = txtl% + INT(diff% / 2)
    ELSEIF fraw% > temp% THEN
        diff% = fraw% - temp%
        butl% = butl% + INT(diff% / 2)
    END IF
    winw% = fraw% + (2 * ospc%): winh% = frah% + buth% + (3 * ospc%)

    file$ = GetUniqueID$
    TempLog file$, "MODULE: MessageBox CONTENTS: Handshake and parameter exchange file."
    rff% = SafeOpenFile%("O", appTempDir$ + file$)
    PRINT #rff%, NewTag$("WIDTH", LTRIM$(STR$(winw%)));
    PRINT #rff%, NewTag$("HEIGHT", LTRIM$(STR$(winh%)));
    PRINT #rff%, NewTag$("TITLE", winTitle$)
    PRINT #rff%, NewTag$("CLASSNAME", "TextC");
    PRINT #rff%, NewTag$("LEFT", LTRIM$(STR$(fral%)));
    PRINT #rff%, NewTag$("TOP", LTRIM$(STR$(frat%)));
    PRINT #rff%, NewTag$("WIDTH", LTRIM$(STR$(fraw%)));
    PRINT #rff%, NewTag$("HEIGHT", LTRIM$(STR$(frah%)));
    PRINT #rff%, NewTag$("FORM", "simple")
    temp$ = ""
    tl% = LEN(iBodyText$)
    FOR i% = 1 TO tl%
        c$ = MID$(iBodyText$, i%, 1)
        IF c$ = "|" OR c$ = "~" OR i% = tl% THEN
            IF temp$ = "" THEN
                IF c$ = "~" THEN
                    PRINT #rff%, NewTag$("CLASSNAME", "RulerC");
                    PRINT #rff%, NewTag$("LENGTH", LTRIM$(STR$(txtw%)));
                    PRINT #rff%, NewTag$("ALIGN", "horizontal");
                    PRINT #rff%, NewTag$("FORM", "ridge");
                    PRINT #rff%, NewTag$("TOP", LTRIM$(STR$(txtt% + INT(INT(txth% * 0.66) / 2) + 1)));
                ELSE
                    PRINT #rff%, NewTag$("CLASSNAME", "TextC");
                    PRINT #rff%, NewTag$("TOP", LTRIM$(STR$(txtt%)));
                    PRINT #rff%, NewTag$("HEIGHT", LTRIM$(STR$(INT(txth% * 0.66))));
                END IF
                txtt% = txtt% + INT(txth% * 0.66)
            ELSE
                PRINT #rff%, NewTag$("CLASSNAME", "TextC");
                PRINT #rff%, NewTag$("TOP", LTRIM$(STR$(txtt%)));
                PRINT #rff%, NewTag$("HEIGHT", LTRIM$(STR$(txth%)));
                txtt% = txtt% + txth%
            END IF
            PRINT #rff%, NewTag$("LEFT", LTRIM$(STR$(txtl%)));
            PRINT #rff%, NewTag$("WIDTH", LTRIM$(STR$(txtw%)));
            FOR j% = 1 TO LEN(temp$)
                IF MID$(temp$, j%, 1) = " " THEN
                    MID$(temp$, j%, 1) = CHR$(255)
                ELSE
                    IF MID$(temp$, j%, 1) = "-" THEN MID$(temp$, j%, 1) = CHR$(4)
                    EXIT FOR
                END IF
            NEXT j%
            PRINT #rff%, NewTag$("TEXT", temp$)
            temp$ = ""
        ELSE
            temp$ = temp$ + c$
        END IF
    NEXT i%
    temp$ = "": temp% = 1
    bl% = LEN(iButtonText$)
    REDIM butArgs$(0)
    FOR i% = 1 TO bl%
        c$ = MID$(iButtonText$, i%, 1)
        IF c$ = "{" THEN
            j% = INSTR(i% + 1, iButtonText$, "}") + 1
            FOR k% = i% + 1 TO j% - 2
                IF MID$(iButtonText$, k%, 1) = "'" THEN MID$(iButtonText$, k%, 1) = CHR$(34)
            NEXT k%
            ub% = ParseLine&(MID$(iButtonText$, i% + 1, j% - i% - 2), butArgs$(), 5)
            IF UCASE$(butArgs$(0)) = "IMG" THEN
                PRINT #rff%, NewTag$("CLASSNAME", "ImageC");
                PRINT #rff%, NewTag$("IMAGEFILE", butArgs$(1));
                PRINT #rff%, NewTag$("LEFT", "7");
                IF butArgs$(2) <> "*" THEN PRINT #rff%, NewTag$("CLEARCOLOR", butArgs$(2));
            ELSEIF UCASE$(butArgs$(0)) = "SYM" THEN
                PRINT #rff%, NewTag$("CLASSNAME", "SymbolC");
                PRINT #rff%, NewTag$("WHICH", butArgs$(1));
                PRINT #rff%, NewTag$("LEFT", "8");
                IF butArgs$(2) <> "*" THEN PRINT #rff%, NewTag$("BACKPEN", butArgs$(2));
                IF butArgs$(3) <> "*" THEN PRINT #rff%, NewTag$("SHADOWPEN", butArgs$(3));
                IF butArgs$(4) <> "*" THEN PRINT #rff%, NewTag$("SHINEPEN", butArgs$(4));
                IF butArgs$(5) <> "*" THEN PRINT #rff%, NewTag$("BORDERPEN", butArgs$(5));
            END IF
            PRINT #rff%, NewTag$("KEEPASPECT", "true");
            PRINT #rff%, NewTag$("TOP", "7");
            PRINT #rff%, NewTag$("HEIGHT", LTRIM$(STR$(buth% - 14)));
            PRINT #rff%, NewTag$("WIDTH", "50")
            i% = j%
            c$ = MID$(iButtonText$, i%, 1)
        END IF
        IF c$ = "|" OR i% = bl% THEN
            IF temp$ <> "" THEN
                PRINT #rff%, NewTag$("CLASSNAME", "ButtonC");
                IF temp% < 11 THEN
                    IF butn% = 1 THEN
                        PRINT #rff%, NewTag$("SHORTCUT", MakeShortcut$("Return", 0, 0, 0));
                    ELSE
                        PRINT #rff%, NewTag$("SHORTCUT", MakeShortcut$(RIGHT$(STR$(temp%), 1), 0, 0, 0));
                        temp% = temp% + 1
                    END IF
                END IF
                PRINT #rff%, NewTag$("LEFT", LTRIM$(STR$(butl%)));
                PRINT #rff%, NewTag$("TOP", LTRIM$(STR$(butt%)));
                PRINT #rff%, NewTag$("WIDTH", LTRIM$(STR$(butw%)));
                PRINT #rff%, NewTag$("HEIGHT", LTRIM$(STR$(buth%)));
                PRINT #rff%, NewTag$("TEXT", temp$)
                temp$ = ""
            END IF
            butl% = butl% + butw% + ospc%
        ELSE
            temp$ = temp$ + c$
        END IF
    NEXT i%
    ERASE butArgs$
    CLOSE rff%

    parMtx%& = PlantMutex%&("Global\RhoSigma-GuiApp-MBParent-" + appProgID$ + CHR$(0))
    putMtx%& = LockMutex%&("Global\RhoSigma-GuiApp-FileAccess-" + file$ + CHR$(0))
    SHELL _HIDE _DONTWAIT CHR$(34) + appFullExe$ + CHR$(34) + " XOBEGASSEM '" + winIcon$ + "' " + file$ + " " + appProgID$
    WHILE NOT CheckMutex%("Global\RhoSigma-GuiApp-MessageBoxHandler-" + appProgID$ + CHR$(0))
        _LIMIT 20
    WEND
    UnlockMutex putMtx%&
    WHILE CheckMutex%("Global\RhoSigma-GuiApp-MessageBoxHandler-" + appProgID$ + CHR$(0))
        _LIMIT 20
        IF _EXIT THEN
            SetTag guiObjects$(0, 0), "USERBREAK", "true"
            EXIT WHILE
        END IF
    WEND
    RemoveMutex parMtx%&
    WHILE CheckMutex%("Global\RhoSigma-GuiApp-MessageBoxHandler-" + appProgID$ + CHR$(0))
        _LIMIT 20
    WEND

    rff% = SafeOpenFile%("I", appTempDir$ + file$)
    LINE INPUT #rff%, MessageBox$
    CLOSE rff%
    KILL appTempDir$ + file$
ELSE
    '--- MessageBox Handler Block ---
    runMtx%& = PlantMutex%&("Global\RhoSigma-GuiApp-MessageBoxHandler-" + buttonText$ + CHR$(0))
    getMtx%& = LockMutex%&("Global\RhoSigma-GuiApp-FileAccess-" + bodyText$ + CHR$(0))
    rff% = SafeOpenFile%("I", appTempDir$ + bodyText$)
    ON ERROR GOTO 0 'avoid recursion, in case of errors
    LINE INPUT #rff%, tags$
    SetupScreen VAL(GetTagData$(tags$, "WIDTH", "320")), VAL(GetTagData$(tags$, "HEIGHT", "240")), -1
    winImg$ = ImageC$("INIT", NewTag$("IMAGEFILE", winIcon$) + NewTag$("LEFT", "0") + NewTag$("TOP", "0"))
    winIco& = VAL(GetTagData$(ImageC$("GET", winImg$ + NewTag$("TAGNAMES", "IHANDLE")), "IHANDLE", "0"))
    IF winIco& < -1 THEN _ICON winIco&
    temp$ = ImageC$("KILL", winImg$)
    _FONT 16
    _TITLE GetTagData$(tags$, "TITLE", "App Message")
    otag$ = ""
    WHILE NOT EOF(rff%)
        LINE INPUT #rff%, tags$
        IF otag$ <> "" THEN tags$ = tags$ + otag$
        temp$ = GenC$("INIT", tags$)
        clas$ = GetTagData$(tags$, "CLASSNAME", "n/a")
        IF clas$ = "ImageC" AND NOT ValidateTags%(temp$, "ERROR", 0) THEN
            otag$ = ImageTag$(temp$) + NewTag$("TEXTMOVEX", "13")
        ELSEIF clas$ = "SymbolC" AND NOT ValidateTags%(temp$, "ERROR", 0) THEN
            otag$ = SymbolTag$(temp$) + NewTag$("TEXTMOVEX", "12")
        ELSE
            otag$ = ""
        END IF
    WEND
    CLOSE rff%
    rff% = SafeOpenFile%("O", appTempDir$ + bodyText$)
    ON ERROR GOTO 0 'avoid recursion, in case of errors
    PRINT #rff%, ""
    CLOSE rff%
    UserErrHandler 'allow for ERROR 1000 immediate exits again
    BeginGUIRefresh
    IF guiViews$(0) = "" THEN FillRectRaster 0, 0, _WIDTH, _HEIGHT, guiShinePen%
    EndGUIRefresh
    _MOUSESHOW
    DO
        _LIMIT 50
        IF NOT CheckMutex%("Global\RhoSigma-GuiApp-MBParent-" + buttonText$ + CHR$(0)) THEN ERROR 1000 'parent is gone, so we do
        mess$ = GetGUIMsg$
        IF BoolTagTrue%(mess$, "USERBREAK") THEN rff% = 0 'cancel (window X button)
        IF BoolTagTrue%(mess$, "KEYPRESS") THEN
            IF GetTagData$(mess$, "KEY", "") = CHR$(27) THEN rff% = 0 'cancel (Esc)
        END IF
        IF ValidateTags%(mess$, "GADGETUP", 0) THEN
            butt$ = ObjectTag$(mess$, "GADGETUP")
            rff% = SafeOpenFile%("O", appTempDir$ + bodyText$)
            ON ERROR GOTO 0 'avoid recursion, in case of errors
            PRINT #rff%, GetTagData$(ButtonC$("GET", butt$ + NewTag$("TAGNAMES", "TEXT")), "TEXT", "")
            CLOSE rff%
            rff% = 0
        END IF
    LOOP WHILE rff% > 0
    CloseScreen
    UnlockMutex getMtx%&
    RemoveMutex runMtx%&
END IF
END FUNCTION

'--- docs\doc_GuiAppframe.bm\FileSelect.html
'---------------------------------------------------------------------
FUNCTION FileSelect$ (winIcon$, winTitle$, opMode%, iniDir$, iniFile$)
FileSelect$ = ""
IF winTitle$ <> "*** RhoSigma-FileSelect-HandlerCall ***" THEN
    '--- FileSelect Setup Block ---
    STATIC fsPatt$, fsCurr$
    IF fsPatt$ = "" THEN fsPatt$ = "(.*)"
    IF iniDir$ = "" THEN iniDir$ = fsCurr$

    file$ = GetUniqueID$
    TempLog file$, "MODULE: FileSelect CONTENTS: Handshake and parameter exchange file."
    rff% = SafeOpenFile%("O", appTempDir$ + file$)
    PRINT #rff%, NewTag$("TITLE", winTitle$);
    PRINT #rff%, NewTag$("TEXT", fsPatt$);
    PRINT #rff%, NewTag$("TEXT", iniDir$);
    PRINT #rff%, NewTag$("TEXT", iniFile$)
    CLOSE rff%

    parMtx%& = PlantMutex%&("Global\RhoSigma-GuiApp-FSParent-" + appProgID$ + CHR$(0))
    putMtx%& = LockMutex%&("Global\RhoSigma-GuiApp-FileAccess-" + file$ + CHR$(0))
    SHELL _HIDE _DONTWAIT CHR$(34) + appFullExe$ + CHR$(34) + " TCELESELIF '" + winIcon$ + "' " + LTRIM$(STR$(opMode%)) + " " + file$ + " " + appProgID$
    WHILE NOT CheckMutex%("Global\RhoSigma-GuiApp-FileSelectHandler-" + appProgID$ + CHR$(0))
        _LIMIT 20
    WEND
    UnlockMutex putMtx%&
    WHILE CheckMutex%("Global\RhoSigma-GuiApp-FileSelectHandler-" + appProgID$ + CHR$(0))
        _LIMIT 20
        IF _EXIT THEN
            SetTag guiObjects$(0, 0), "USERBREAK", "true"
            EXIT WHILE
        END IF
    WEND
    RemoveMutex parMtx%&
    WHILE CheckMutex%("Global\RhoSigma-GuiApp-FileSelectHandler-" + appProgID$ + CHR$(0))
        _LIMIT 20
    WEND

    rff% = SafeOpenFile%("I", appTempDir$ + file$)
    LINE INPUT #rff%, FileSelect$
    LINE INPUT #rff%, fsPatt$
    LINE INPUT #rff%, fsCurr$
    CLOSE rff%
    KILL appTempDir$ + file$
ELSE
    '--- FileSelect Handler Block ---
    runMtx%& = PlantMutex%&("Global\RhoSigma-GuiApp-FileSelectHandler-" + iniFile$ + CHR$(0))
    getMtx%& = LockMutex%&("Global\RhoSigma-GuiApp-FileAccess-" + iniDir$ + CHR$(0))
    '--- get handshake tags ---
    rff% = SafeOpenFile%("I", appTempDir$ + iniDir$)
    LINE INPUT #rff%, tags$: CLOSE rff%
    '--- init window ---
    SetupScreen 440, 520, -1
    winImg$ = ImageC$("INIT", NewTag$("IMAGEFILE", winIcon$) + NewTag$("LEFT", "0") + NewTag$("TOP", "0"))
    winIco& = VAL(GetTagData$(ImageC$("GET", winImg$ + NewTag$("TAGNAMES", "IHANDLE")), "IHANDLE", "0"))
    IF winIco& < -1 THEN _ICON winIco&
    resu$ = ImageC$("KILL", winImg$)
    titl$ = "Select a file ...": mode$ = "File Load Mode."
    IF opMode% = fsmDIRS% THEN
        titl$ = "Select a drawer ..."
        mode$ = "Folder Only Mode."
    ELSEIF opMode% = fsmSAVE% THEN
        mode$ = "File Save Mode."
    END IF
    _TITLE GetTagData$(tags$, "TITLE", titl$)
    _FONT 16
    '--- build GUI ---
    nore% = (NOT RegexIsActive%): nofi% = (opMode% = fsmDIRS%)
    back% = guiLoadBack%: IF opMode% = fsmSAVE% THEN back% = guiSaveBack%
    inim$ = ImageC$("INIT", NewTag$("LEFT", "0") + NewTag$("TOP", "0") + NewTag$("WIDTH", "42") + NewTag$("HEIGHT", "32") +_
                     NewTag$("IMAGEFILE", "Info32px.png") + NewTag$("CLEARCOLOR", "39") + NewTag$("KEEPASPECT", "true"))
    erim$ = ImageC$("INIT", NewTag$("LEFT", "0") + NewTag$("TOP", "0") + NewTag$("WIDTH", "42") + NewTag$("HEIGHT", "32") +_
                     NewTag$("IMAGEFILE", "Error32px.png") + NewTag$("CLEARCOLOR", "39") + NewTag$("KEEPASPECT", "true"))
    dlsy$ = SymbolC$("INIT", NewTag$("LEFT", "0") + NewTag$("TOP", "0") + NewTag$("WIDTH", "21") + NewTag$("HEIGHT", "17") +_
                     NewTag$("WHICH", "MediaDisk") + NewTag$("KEEPASPECT", "true"))
    fldr$ = SymbolC$("INIT", NewTag$("LEFT", "0") + NewTag$("TOP", "0") + NewTag$("WIDTH", "21") + NewTag$("HEIGHT", "17") +_
                     NewTag$("WHICH", "MediaDrawer") + NewTag$("KEEPASPECT", "true"))
    flfi$ = SymbolC$("INIT", NewTag$("LEFT", "0") + NewTag$("TOP", "0") + NewTag$("WIDTH", "21") + NewTag$("HEIGHT", "17") +_
                     NewTag$("WHICH", "MediaFile") + NewTag$("KEEPASPECT", "true"))
    rlis$ = ListC$("INIT", "")
    resu$ = ListC$("STORE", rlis$ + NewTag$("DATA", CHR$(255)))
    resu$ = ListC$("STORE", rlis$ + NewTag$("DATA", CHR$(255)) + ImageTag$(inim$))
    resu$ = ListC$("STORE", rlis$ + NewTag$("DATA", STRING$(3, CHR$(255)) + "please wait,"))
    resu$ = ListC$("STORE", rlis$ + NewTag$("DATA", CHR$(255)))
    resu$ = ListC$("STORE", rlis$ + NewTag$("DATA", STRING$(6, CHR$(255)) + "reading directory ..."))
    resu$ = ListC$("STORE", rlis$ + NewTag$("DATA", CHR$(255)))
    resu$ = ListC$("STORE", rlis$ + NewTag$("DATA", STRING$(2, CHR$(255)) + CHR$(4) + " hit any key to abort reading and show"))
    resu$ = ListC$("STORE", rlis$ + NewTag$("DATA", STRING$(4, CHR$(255)) + "what I have so far ..."))
    dlis$ = ListC$("INIT", "")
    FOR i% = 1 TO LEN(appDrives$)
        resu$ = ListC$("STORE", dlis$ + NewTag$("DATA", MID$(appDrives$, i%, 1) + ":\" + SPACE$(35) + "<DRIVE>") + SymbolTag$(dlsy$))
    NEXT i%
    allo$ = ""
    FOR i% = 32 TO 255
        SELECT CASE i%
            CASE 34, 42, 47, 58, 60, 62, 63, 92, 124
                'not allowed
            CASE ELSE
                allo$ = allo$ + CHR$(i%)
        END SELECT
    NEXT i%
    fstx$ = TextC$("INIT", NewTag$("LEFT", "8") + NewTag$("TOP", "8") + NewTag$("WIDTH", "424") + NewTag$("HEIGHT", "30") +_
                   NewTag$("TEXT", "Dirs: 0 / Files: 0 / Usage: 0") + NewTag$("TEXTPLACE", "center") + NewTag$("FORM", "ridge") +_
                   NewTag$("TOOLTIP", "<<< Statistics >>>|Usage is the overall size of|the currently listed files."))
    fslv$ = ListviewC$("INIT", NewTag$("LEFT", "8") + NewTag$("TOP", "43") + NewTag$("WIDTH", "424") + NewTag$("HEIGHT", "328") +_
                       NewTag$("SPACING", "3") + NewTag$("READONLY", "true") + ListTag$(rlis$) +_
                       NewTag$("TOOLTIP", "Listing of the currently selected folder.|The dialog is in " + mode$ + "|--------------------|You may navigate the list using the mouse.|While the mouse is resting over the list|area, the arrow keys incl. Home, End, PgUp|and PgDown can be used as well. Also|Ctrl + wheel is same as arrow keys."))
    refo$ = NewTag$("REFOBJ", GetTagData$(fslv$, "OBJECT", "0"))
    fsre$ = StringC$("INIT", NewTag$("LEFT", "77") + NewTag$("TOP", "375") + NewTag$("WIDTH", "355") + NewTag$("HEIGHT", "30") +_
                     ExtractTag$(tags$, "TEXT") + NewTag$("MAXIMUM", "40") + NewTag$("DISABLED", LTRIM$(STR$(nore% OR nofi%))) +_
                     NewTag$("LABEL", "Pattern:") + NewTag$("LABELHIGH", "true") + NewTag$("LABELPLACE", "left") +_
                     NewTag$("TOOLTIP", "RegEx based pattern to filter the file|list, folder names are not affected.|The matching process does ignore case."))
    fspa$ = StringC$("INIT", NewTag$("LEFT", "53") + NewTag$("TOP", "409") + NewTag$("WIDTH", "379") + NewTag$("HEIGHT", "30") +_
                     ExtractTag$(tags$, "TEXT") + NewTag$("MAXIMUM", "246") + NewTag$("ALLOWED", ":\" + allo$) +_
                     NewTag$("LABEL", "Path:") + NewTag$("LABELHIGH", "true") + NewTag$("LABELPLACE", "left") +_
                     NewTag$("TOOLTIP", "Currently selected path.|Append a new name to create a|new folder in File Save Mode."))
    fsfi$ = StringC$("INIT", NewTag$("LEFT", "53") + NewTag$("TOP", "443") + NewTag$("WIDTH", "379") + NewTag$("HEIGHT", "30") +_
                     ExtractTag$(tags$, "TEXT") + NewTag$("MAXIMUM", "259") + NewTag$("ALLOWED", allo$) + NewTag$("PASSIVE", "true") + NewTag$("DISABLED", LTRIM$(STR$(nofi%))) +_
                     NewTag$("LABEL", "File:") + NewTag$("LABELHIGH", "true") + NewTag$("LABELPLACE", "left") +_
                     NewTag$("TOOLTIP", "Currently selected file.|Enter or change its name|in File Save Mode here."))
    sesy$ = SymbolC$("INIT", NewTag$("LEFT", "16") + NewTag$("TOP", "7") + NewTag$("WIDTH", "50") + NewTag$("HEIGHT", "17") +_
                     NewTag$("WHICH", "Checkmark") + NewTag$("KEEPASPECT", "true"))
    sebu$ = ButtonC$("INIT", NewTag$("LEFT", "8") + NewTag$("TOP", "481") + NewTag$("WIDTH", "100") + NewTag$("HEIGHT", "31") +_
                     NewTag$("TEXT", "Select") + NewTag$("TEXTMOVEX", "8") + SymbolTag$(sesy$) + NewTag$("DISABLED", "true") +_
                     NewTag$("TOOLTIP", "Take selected file/folder|and close the dialog.|Left double-click on the|file in the list or press|<Enter> does the same in|File Load Mode only."))
    drsy$ = SymbolC$("INIT", NewTag$("LEFT", "14") + NewTag$("TOP", "7") + NewTag$("WIDTH", "50") + NewTag$("HEIGHT", "17") +_
                     NewTag$("WHICH", "MediaDisk") + NewTag$("KEEPASPECT", "true"))
    drbu$ = ButtonC$("INIT", NewTag$("LEFT", "116") + NewTag$("TOP", "481") + NewTag$("WIDTH", "100") + NewTag$("HEIGHT", "31") +_
                     NewTag$("TEXT", "Drives") + NewTag$("TEXTMOVEX", "10") + SymbolTag$(drsy$) +_
                     NewTag$("TOOLTIP", "List all drives.|Pressing <D> or a|middle-click will|do the same."))
    pasy$ = SymbolC$("INIT", NewTag$("LEFT", "13") + NewTag$("TOP", "7") + NewTag$("WIDTH", "50") + NewTag$("HEIGHT", "17") +_
                     NewTag$("WHICH", "MediaDrawer") + NewTag$("KEEPASPECT", "true"))
    pabu$ = ButtonC$("INIT", NewTag$("LEFT", "224") + NewTag$("TOP", "481") + NewTag$("WIDTH", "100") + NewTag$("HEIGHT", "31") +_
                     NewTag$("TEXT", "Parent") + NewTag$("TEXTMOVEX", "13") + SymbolTag$(pasy$) +_
                     NewTag$("TOOLTIP", "One folder back.|Press <Backspace> or|a right-click will|do the same."))
    casy$ = SymbolC$("INIT", NewTag$("LEFT", "14") + NewTag$("TOP", "7") + NewTag$("WIDTH", "50") + NewTag$("HEIGHT", "17") +_
                     NewTag$("WHICH", "Cross") + NewTag$("KEEPASPECT", "true"))
    cabu$ = ButtonC$("INIT", NewTag$("LEFT", "332") + NewTag$("TOP", "481") + NewTag$("WIDTH", "100") + NewTag$("HEIGHT", "31") +_
                     NewTag$("TEXT", "Cancel") + NewTag$("TEXTMOVEX", "10") + SymbolTag$(casy$) +_
                     NewTag$("TOOLTIP", "Close the dialog|without selection.|Pressing <Esc> or|closing the window|will do the same."))
    BeginGUIRefresh
    IF guiViews$(0) = "" THEN FillRectColor 0, 0, _WIDTH, _HEIGHT, back%
    EndGUIRefresh
    GOSUB fsReadDir
    GOSUB fsChkButtonStates
    '--- operate GUI ---
    _MOUSESHOW
    DO
        _LIMIT 50
        IF NOT CheckMutex%("Global\RhoSigma-GuiApp-FSParent-" + iniFile$ + CHR$(0)) THEN
            GOSUB fsWriteCancelResult
            ERROR 1000 'parent is gone, so we do
        END IF
        mess$ = GetGUIMsg$
        IF BoolTagTrue%(mess$, "USERBREAK") THEN
            GOSUB fsWriteCancelResult
            rff% = 0 'cancel (window X button)
        END IF
        kpFlag% = 0
        IF BoolTagTrue%(mess$, "KEYPRESS") THEN
            IF GetTagData$(mess$, "KEY", "") = CHR$(8) THEN
                RemTag mess$, "GADGETUP": kpFlag% = -1
                mess$ = mess$ + ChildTag$("GADGETUP", pabu$) 'fake parent button event
            ELSEIF GetTagData$(mess$, "KEY", "") = CHR$(13) THEN
                RemTag mess$, "GADGETUP": kpFlag% = -1
                mess$ = mess$ + ChildTag$("GADGETUP", fslv$) 'fake listview event
            ELSEIF GetTagData$(mess$, "KEY", "") = CHR$(27) THEN
                GOSUB fsWriteCancelResult
                rff% = 0 'cancel (Esc)
            ELSEIF UCASE$(GetTagData$(mess$, "KEY", "")) = "D" THEN
                RemTag mess$, "GADGETUP": kpFlag% = -1
                mess$ = mess$ + ChildTag$("GADGETUP", drbu$) 'fake drives button event
            END IF
        END IF
        IF ValidateTags%(mess$, "GADGETUP", 0) OR BoolTagTrue%(mess$, "MOUSEMBDOWN") OR _
                                                  BoolTagTrue%(mess$, "MOUSERBDOWN") THEN
            curr$ = GetTagData$(StringC$("GET", fspa$ + NewTag$("TAGNAMES", "TEXT")), "TEXT", "")
            file$ = GetTagData$(StringC$("GET", fsfi$ + NewTag$("TAGNAMES", "TEXT")), "TEXT", "")
            '-----
            IF ThisObject%(fslv$, mess$, "GADGETUP") THEN
                node$ = ListviewC$("GET", fslv$ + NewTag$("TAGNAMES", "DATA,FSREAL"))
                entr$ = GetTagData$(node$, "DATA", ""): real$ = GetTagData$(node$, "FSREAL", "n/a")
                IF RIGHT$(entr$, 7) = "<DRIVE>" THEN
                    IF (odir$ = entr$) OR kpFlag% THEN
                        resu$ = StringC$("SET", fspa$ + NewTag$("TEXT", LEFT$(entr$, 3)))
                        GOSUB fsReadDir
                        odir$ = "": dcdt% = 0
                        ofil$ = "": dcft% = 0
                    ELSE
                        odir$ = entr$: dcdt% = 15
                        ofil$ = "": dcft% = 0
                    END IF
                ELSEIF real$ <> "n/a" THEN
                    IF RIGHT$(entr$, 8) = "<DRAWER>" THEN
                        IF (odir$ = real$) OR kpFlag% THEN
                            resu$ = StringC$("SET", fspa$ + NewTag$("TEXT", curr$ + real$))
                            GOSUB fsReadDir
                            odir$ = "": dcdt% = 0
                            ofil$ = "": dcft% = 0
                        ELSE
                            odir$ = real$: dcdt% = 15
                            ofil$ = "": dcft% = 0
                        END IF
                    ELSE
                        IF ((ofil$ = real$) OR kpFlag%) AND (opMode% <> fsmSAVE%) THEN
                            IF RIGHT$(entr$, 8) <> "<DENIED>" THEN
                                GOSUB fsWriteSelectResult
                                rff% = 0 'select (double click)
                            END IF
                        ELSE
                            resu$ = StringC$("SET", fsfi$ + NewTag$("TEXT", real$))
                            file$ = real$
                            odir$ = "": dcdt% = 0
                            ofil$ = real$: dcft% = 15
                        END IF
                    END IF
                END IF
            END IF
            IF ThisObject%(fsre$, mess$, "GADGETUP") THEN
                patt$ = GetTagData$(StringC$("GET", fsre$ + NewTag$("TAGNAMES", "TEXT")), "TEXT", "")
                IF patt$ <> "" THEN
                    vali% = RegexMatch%("TestString" + CHR$(0), patt$ + CHR$(0))
                    IF vali% < 0 THEN
                        resu$ = MessageBox$("Error16px.png", "FileSelect",_
                                            "Error in RegEx pattern, fallback method will match all.|~" +_
                                            " - " + RegexError$(vali%), "{SYM Checkmark * * * *}Continue")
                    END IF
                ELSE
                    resu$ = StringC$("SET", fsre$ + NewTag$("TEXT", "(.*)"))
                END IF
                GOSUB fsReadDir
            END IF
            IF ThisObject%(fspa$, mess$, "GADGETUP") THEN
                WHILE LEFT$(curr$, 1) = "\": curr$ = MID$(curr$, 2): WEND
                resu$ = StringC$("SET", fspa$ + NewTag$("TEXT", curr$))
                IF opMode% = fsmSAVE% THEN
                    IF MID$(curr$, 2, 2) <> ":\" THEN curr$ = CurrDIR$ + "\" + curr$
                    IF NOT _DIREXISTS(curr$) THEN
                        resu$ = MessageBox$("Error16px.png", "FileSelect",_
                                            "Path does not exist yet !!",_
                                            "{SYM Checkmark * * * *}Create|{SYM Cross * * * *}Ignore")
                        IF resu$ = "Create" THEN
                            temp$ = curr$: colo% = 0
                            FOR i% = 1 TO LEN(temp$)
                                SELECT CASE MID$(temp$, i%, 1)
                                    CASE ":": colo% = colo% + 1
                                    CASE "\": MID$(temp$, i%, 1) = " "
                                    CASE " ": MID$(temp$, i%, 1) = "*"
                                END SELECT
                            NEXT i%
                            IF colo% > 1 THEN
                                resu$ = MessageBox$("Error16px.png", "FileSelect",_
                                                    "Invalid char (:) in name !!", "")
                            ELSE
                                REDIM car$(0)
                                cub% = ParseLine&(temp$, car$(), 0)
                                IF cub% > 0 THEN
                                    temp$ = car$(0)
                                    FOR i% = 1 TO cub%
                                        FOR j% = 1 TO LEN(car$(i%))
                                            IF MID$(car$(i%), j%, 1) = "*" THEN MID$(car$(i%), j%, 1) = " "
                                        NEXT j%
                                        temp$ = temp$ + "\" + car$(i%)
                                        IF NOT _DIREXISTS(temp$) THEN
                                            InternalErrHandler
                                            MKDIR temp$
                                            UserErrHandler
                                        END IF
                                    NEXT i%
                                END IF
                                ERASE car$
                            END IF
                        END IF
                    END IF
                END IF
                GOSUB fsReadDir
            END IF
            IF ThisObject%(fsfi$, mess$, "GADGETUP") THEN
                WHILE LEFT$(file$, 1) = "\": file$ = MID$(file$, 2): WEND
                IF MID$(file$, 2, 2) = ":\" THEN curr$ = ""
                IF file$ <> "" AND _DIREXISTS(curr$ + file$) THEN
                    curr$ = curr$ + file$
                    resu$ = StringC$("SET", fspa$ + NewTag$("TEXT", curr$))
                    resu$ = StringC$("SET", fsfi$ + NewTag$("TEXT", ""))
                    GOSUB fsReadDir
                ELSE
                    spos% = RInstr&(0, file$, "\")
                    IF spos% = 0 THEN
                        GOSUB fsChkFile
                        IF opMode% <> fsmSAVE% AND _FILEEXISTS(curr$ + file$) THEN
                            GOSUB fsWriteSelectResult
                            rff% = 0 'select (typed filename)
                        END IF
                    ELSE
                        curr$ = curr$ + LEFT$(file$, spos% - 1)
                        resu$ = StringC$("SET", fspa$ + NewTag$("TEXT", curr$))
                        resu$ = StringC$("SET", fsfi$ + NewTag$("TEXT", MID$(file$, spos% + 1)))
                        GOSUB fsReadDir
                    END IF
                END IF
            END IF
            IF ThisObject%(sebu$, mess$, "GADGETUP") THEN
                IF opMode% = fsmSAVE% AND LEN(curr$ + file$) > 259 THEN
                    resu$ = MessageBox$("Error16px.png", "FileSelect",_
                                        "Path + File to long !!|~" +_
                                        "Use other location or|" +_
                                        "shortcut the filename.", "")
                ELSE
                    GOSUB fsWriteSelectResult
                    rff% = 0 'select (button)
                END IF
            END IF
            IF ThisObject%(drbu$, mess$, "GADGETUP") OR BoolTagTrue%(mess$, "MOUSEMBDOWN") THEN
                resu$ = TextC$("SET", fstx$ + NewTag$("TEXT", "Drives:" + STR$(LEN(appDrives$))))
                resu$ = ListviewC$("SET", fslv$ + NewTag$("READONLY", "false") + NewTag$("ACTUAL", "0") + ListTag$(dlis$))
                dlis% = -1
            END IF
            IF ThisObject%(pabu$, mess$, "GADGETUP") OR BoolTagTrue%(mess$, "MOUSERBDOWN") THEN
                IF (NOT disa%) OR dlis% THEN
                    IF NOT dlis% THEN
                        curr$ = GetTagData$(StringC$("GET", fspa$ + NewTag$("TAGNAMES", "TEXT")), "TEXT", "")
                        spos% = RInstr&(LEN(curr$) - 1, curr$, "\"): IF spos% = 0 THEN spos% = 1
                        curr$ = LEFT$(curr$, spos% - 1)
                        resu$ = StringC$("SET", fspa$ + NewTag$("TEXT", curr$))
                    END IF
                    GOSUB fsReadDir
                END IF
            END IF
            IF ThisObject%(cabu$, mess$, "GADGETUP") THEN
                GOSUB fsWriteCancelResult
                rff% = 0 'cancel (button)
            END IF
            '-----
            GOSUB fsChkButtonStates
        END IF
        IF dcdt% > 0 THEN
            dcdt% = dcdt% - 1
            IF dcdt% = 0 THEN odir$ = ""
        END IF
        IF dcft% > 0 THEN
            dcft% = dcft% - 1
            IF dcft% = 0 THEN ofil$ = ""
        END IF
    LOOP WHILE rff% > 0
    CloseScreen
    UnlockMutex getMtx%&
    RemoveMutex runMtx%&
END IF
EXIT FUNCTION
'----------------------------------
fsWriteSelectResult:
rff% = SafeOpenFile%("O", appTempDir$ + iniDir$)
PRINT #rff%, curr$; file$
PRINT #rff%, GetTagData$(StringC$("GET", fsre$ + NewTag$("TAGNAMES", "TEXT")), "TEXT", "")
PRINT #rff%, curr$
CLOSE rff%
RETURN
'----------------------------------
fsWriteCancelResult:
rff% = SafeOpenFile%("O", appTempDir$ + iniDir$)
PRINT #rff%, ""
PRINT #rff%, GetTagData$(StringC$("GET", fsre$ + NewTag$("TAGNAMES", "TEXT")), "TEXT", "")
PRINT #rff%, GetTagData$(StringC$("GET", fspa$ + NewTag$("TAGNAMES", "TEXT")), "TEXT", "")
CLOSE rff%
RETURN
'----------------------------------
fsChkButtonStates:
IF opMode% = fsmSAVE% OR opMode% = fsmDIRS% THEN
    disa% = (NOT _DIREXISTS(curr$)) OR aerr%
    IF opMode% = fsmSAVE% AND file$ = "" THEN disa% = -1
ELSE
    disa% = (NOT _FILEEXISTS(curr$ + file$))
END IF
resu$ = ButtonC$("SET", sebu$ + NewTag$("DISABLED", LTRIM$(STR$(disa%))))
IF LEN(curr$) = 3 AND RIGHT$(curr$, 2) = ":\" THEN disa% = -1: ELSE disa% = 0
resu$ = ButtonC$("SET", pabu$ + NewTag$("DISABLED", LTRIM$(STR$(disa%))))
RETURN
'----------------------------------
fsReadDir:
dlis% = 0: aerr% = 0: ro$ = NewTag$("READONLY", "false")
resu$ = ListviewC$("SET", fslv$ + NewTag$("READONLY", "true") + ListTag$(rlis$))
resu$ = ListC$("KILL", tlis$) 'kill old temp dir list
tlis$ = ListC$("INIT", "") 'create new temp dir list
resu$ = ListC$("KILL", flis$) 'kill old file list
flis$ = ListC$("INIT", "") 'create new file list

nd& = 0: nf& = 0: nu&& = 0
text$ = Format3$("Dirs:& / Files:& / Usage:&", STR$(nd&), 0, STR$(nf&), 0, STR$(nu&&), 0)
resu$ = TextC$("SET", fstx$ + NewTag$("TEXT", text$))

patt$ = GetTagData$(StringC$("GET", fsre$ + NewTag$("TAGNAMES", "TEXT")), "TEXT", "")
curr$ = GetTagData$(StringC$("GET", fspa$ + NewTag$("TAGNAMES", "TEXT")), "TEXT", CurrDIR$)
IF curr$ = "" THEN curr$ = CurrDIR$
IF NOT _DIREXISTS(curr$) THEN
    resu$ = ListC$("STORE", flis$ + NewTag$("DATA", CHR$(255))): ro$ = NewTag$("READONLY", "true")
    resu$ = ListC$("STORE", flis$ + NewTag$("DATA", CHR$(255)) + ImageTag$(erim$))
    IF LEN(curr$) = 3 AND RIGHT$(curr$, 2) = ":\" THEN
        resu$ = ListC$("STORE", flis$ + NewTag$("DATA", STRING$(6, CHR$(255)) + "permission denied or"))
        resu$ = ListC$("STORE", flis$ + NewTag$("DATA", STRING$(7, CHR$(255)) + "no media in (removeable) drive ..."))
    ELSE
        resu$ = ListC$("STORE", flis$ + NewTag$("DATA", STRING$(6, CHR$(255)) + "path not found ..."))
    END IF
    actu$ = "0": GOTO fsChkFile
ELSE
    IF LEN(curr$) > 3 OR MID$(curr$, 2, 1) <> ":" THEN
        ocur$ = CurrDIR$
        InternalErrHandler
        CHDIR curr$
        UserErrHandler
        IF appLastErr% = 0 THEN
            curr$ = CurrDIR$
        ELSEIF appLastErr% = 76 THEN
            resu$ = ListC$("STORE", flis$ + NewTag$("DATA", CHR$(255))): ro$ = NewTag$("READONLY", "true")
            resu$ = ListC$("STORE", flis$ + NewTag$("DATA", CHR$(255)) + ImageTag$(erim$))
            resu$ = ListC$("STORE", flis$ + NewTag$("DATA", STRING$(6, CHR$(255)) + "permission denied ..."))
            aerr% = -1
        END IF
        CHDIR ocur$
    END IF
END IF
IF RIGHT$(curr$, 1) <> "\" THEN curr$ = curr$ + "\"
resu$ = StringC$("SET", fspa$ + NewTag$("TEXT", curr$))

dhan%& = BeginDirRead%&(curr$ + CHR$(0))
IF dhan%& <> 0 THEN
    div% = 10
    DO
        entr$ = GetDirEntry$(dhan%&)
        IF entr$ <> "" AND entr$ <> "." AND entr$ <> ".." THEN
            IF _DIREXISTS(curr$ + entr$) THEN
                real$ = entr$
                IF LEN(entr$) > 34 THEN
                    entr$ = LEFT$(entr$, 31) + "..."
                ELSE
                    entr$ = entr$ + SPACE$(34 - LEN(entr$))
                END IF
                resu$ = ListC$("STORE", tlis$ + NewTag$("DATA", entr$ + "   <DRAWER>") + NewTag$("FSREAL", real$) + SymbolTag$(fldr$))
                nd& = nd& + 1
            ELSE
                IF NOT nofi% THEN
                    IF RegexMatch%(UCASE$(entr$) + CHR$(0), UCASE$(patt$) + CHR$(0)) THEN 'if match or faulty regex
                        eff% = SafeOpenFile%("B", curr$ + entr$)
                        IF eff% <> 0 THEN
                            elof$ = LTRIM$(STR$(LOF(eff%) AND &HFFFFFFFFFFFFFFFF)) 'force int64 for STR$()
                            elof$ = SPACE$(11 - LEN(elof$)) + elof$
                            CLOSE eff%
                            nu&& = nu&& + VAL(elof$)
                        ELSE
                            elof$ = "   <DENIED>"
                        END IF
                        real$ = entr$
                        IF LEN(entr$) > 34 THEN
                            entr$ = LEFT$(entr$, 31) + "..."
                        ELSE
                            entr$ = entr$ + SPACE$(34 - LEN(entr$))
                        END IF
                        resu$ = ListC$("STORE", flis$ + NewTag$("DATA", entr$ + elof$) + NewTag$("FSREAL", real$) + SymbolTag$(flfi$))
                        nf& = nf& + 1
                    END IF
                END IF
            END IF
            IF ((nd& + nf&) MOD div%) = 0 THEN
                IF (nd& + nf&) = 100 THEN div% = 100
                text$ = Format3$("Dirs:& / Files:& / Usage:&", STR$(nd&), 0, STR$(nf&), 0, STR$(nu&&), 0)
                resu$ = TextC$("SET", fstx$ + NewTag$("TEXT", text$))
            END IF
        END IF
    LOOP UNTIL entr$ = "" OR INKEY$ <> ""
    EndDirRead dhan%&
    text$ = Format3$("Dirs:& / Files:& / Usage:&", STR$(nd&), 0, STR$(nf&), 0, STR$(nu&&), 0)
    resu$ = TextC$("SET", fstx$ + NewTag$("TEXT", text$))
END IF

tlob& = VAL(GetTagData$(tlis$, "OBJECT", "0")): trec& = VAL(GetTagData$(guiObjects$(objData%, tlob&), "RECORDS", "0"))
IF trec& > 0 THEN
    flob& = VAL(GetTagData$(flis$, "OBJECT", "0")): frec& = VAL(GetTagData$(guiObjects$(objData%, flob&), "RECORDS", "0"))
    SetTag guiObjects$(objData%, flob&), "RECORDS", LTRIM$(STR$(trec& + frec&))
    tnod& = VAL(GetTagData$(guiObjects$(objData%, tlob&), "LAST", "0")): fnod& = VAL(GetTagData$(guiObjects$(objData%, flob&), "FIRST", "0"))
    SetTag guiObjects$(objData%, tnod&), "NEXT", LTRIM$(STR$(fnod&)): SetTag guiObjects$(objData%, fnod&), "PREVIOUS", LTRIM$(STR$(tnod&))
    RemTag guiObjects$(objData%, flob&), "FIRST": guiObjects$(objData%, flob&) = guiObjects$(objData%, flob&) + GetTags$(guiObjects$(objData%, tlob&), "FIRST,HASLVIS")
    guiObjects$(objData%, tlob&) = NewTag$("ACTUAL", "0") + NewTag$("RECORDS", "0")
END IF

fsChkFile:
file$ = GetTagData$(StringC$("GET", fsfi$ + NewTag$("TAGNAMES", "TEXT")), "TEXT", "")
reco$ = GetTagData$(ListC$("GET", flis$ + refo$ + NewTag$("TAGNAMES", "RECORDS")), "RECORDS", "0")
IF nofi% THEN file$ = ""
IF VAL(reco$) > 0 THEN
    IF file$ <> "" THEN
        resu$ = ListC$("SEARCH", flis$ + refo$ + NewTag$("DATA", file$) + NewTag$("PARTIAL", "left") + NewTag$("NOCASE", "true") + NewTag$("HOLD", "true"))
        IF resu$ <> "" THEN actu$ = GetTagData$(ListC$("GET", flis$ + refo$ + NewTag$("TAGNAMES", "ACTUAL")), "ACTUAL", "1")
    END IF
    IF file$ = "" OR resu$ = "" THEN actu$ = "0"
ELSE
    resu$ = ListC$("STORE", flis$ + NewTag$("DATA", CHR$(255))): ro$ = NewTag$("READONLY", "true")
    resu$ = ListC$("STORE", flis$ + NewTag$("DATA", CHR$(255)) + ImageTag$(inim$))
    IF nofi% THEN
        resu$ = ListC$("STORE", flis$ + NewTag$("DATA", STRING$(6, CHR$(255)) + "no more directories here ..."))
    ELSEIF patt$ <> "(.*)" THEN
        resu$ = ListC$("STORE", flis$ + NewTag$("DATA", STRING$(6, CHR$(255)) + "no pattern matches here ..."))
    ELSE
        resu$ = ListC$("STORE", flis$ + NewTag$("DATA", STRING$(6, CHR$(255)) + "empty directory ..."))
    END IF
    actu$ = "0"
END IF

IF actu$ = "0" AND opMode% <> fsmSAVE% THEN file$ = ""
resu$ = StringC$("SET", fsfi$ + NewTag$("TEXT", file$))
resu$ = ListviewC$("SET", fslv$ + ro$ + NewTag$("ACTUAL", actu$) + ListTag$(flis$))
RETURN
END FUNCTION

'--- docs\doc_GuiAppframe.bm\GetUniqueID.html
'---------------------------------------------------------------------
FUNCTION GetUniqueID$
REDIM vars(0) AS ChunkVARS
'--- exclusivly access the unique ID source file ---
mtx%& = LockMutex%&("Global\RhoSigma-GuiApp-FileAccess-univars.tmp" + CHR$(0))
iff% = SafeOpenFile%("B", appTempDir$ + "univars.tmp")
ptr& = SeekChunk&(iff%, CHvarsID$)
GET iff%, , vars(0)
'--- create ID and update vital values ---
GetUniqueID$ = RIGHT$("00000000" + HEX$(vars(0).varsFID), 8) + "." + RIGHT$("000" + HEX$(vars(0).varsEID), 3)
vars(0).varsEID = vars(0).varsEID + 1
IF vars(0).varsEID = 4096 THEN
    vars(0).varsEID = 0
    IF NOT vars(0).varsIDF THEN
        vars(0).varsFID = vars(0).varsFID + 1
    ELSE
        vars(0).varsFID = -2147483648
        vars(0).varsIDF = 0
    END IF
    IF vars(0).varsFID = 2147483647 THEN
        vars(0).varsIDF = -1
    END IF
END IF
'--- update & close the unique ID source file ---
PUT iff%, ptr&, vars(0)
CLOSE iff%
UnlockMutex mtx%&
'--- cleanup & return ---
ERASE vars
END FUNCTION

'--- docs\doc_GuiAppframe.bm\TempLog.html
'---------------------------------------------------------------------
SUB TempLog (file$, comm$)
REDIM thdr(0) AS ChunkTHDR
REDIM tlog(0) AS ChunkTLOG
'--- exclusivly access the temp logfile ---
mtx%& = LockMutex%&("Global\RhoSigma-GuiApp-FileAccess-templog.tmp" + CHR$(0))
iff% = SafeOpenFile%("B", appTempDir$ + "templog.tmp")
ptr& = SeekChunk&(iff%, CHthdrID$)
GET iff%, , thdr(0)
'--- check for a free entry to use ---
IF thdr(0).thdrUNUSED > 0 THEN
    thdr(0).thdrUNUSED = thdr(0).thdrUNUSED - 1
    PUT iff%, ptr&, thdr(0)
    ptr& = SeekChunk&(iff%, CHfreeID$)
    GET iff%, , tlog(0)
    flag% = -1
ELSE
    flag% = 0
END IF
'--- init entry with given info ---
tlog(0).tlogSTDC.chunkID = CHtlogID$
tlog(0).tlogSTDC.chunkLEN = CHtlogLEN%
tlog(0).tlogNAME = FilePart$(file$)
tlog(0).tlogACCESSOR = appProgID$
tlog(0).tlogCOMMENT = comm$
'--- write updated/new entry & close logfile ---
IF flag% THEN
    PUT iff%, ptr&, tlog(0)
ELSE
    PUT iff%, LOF(iff%) + 1, tlog(0)
    SizeUpdate iff%, tlogSIZEOF%
END IF
CLOSE iff%
UnlockMutex mtx%&
'--- cleanup & return ---
ERASE tlog
ERASE thdr
END SUB

'--- docs\doc_GuiAppframe.bm\SetPrintMode.html
'---------------------------------------------------------------------
SUB SetPrintMode (pm%)
SELECT CASE pm%
    CASE 1: _PRINTMODE _KEEPBACKGROUND
    CASE 2: _PRINTMODE _ONLYBACKGROUND
    CASE 3: _PRINTMODE _FILLBACKGROUND
END SELECT
END SUB

'--- docs\doc_GuiAppframe.bm\InternalErrHandler.html
'---------------------------------------------------------------------
SUB InternalErrHandler
appLastErr% = 0
IF UCASE$(ErrorHandlerSwitch$) <> "DISABLED" THEN
    ON ERROR GOTO InternalErrorHandler
ELSE
    ON ERROR GOTO 0
END IF
END SUB

'--- docs\doc_GuiAppframe.bm\UserErrHandler.html
'---------------------------------------------------------------------
SUB UserErrHandler
IF UCASE$(ErrorHandlerSwitch$) = "ON" THEN
    ON ERROR GOTO UserErrorHandler
ELSE
    ON ERROR GOTO 0
END IF
END SUB

'--- docs\doc_GuiAppframe.bm\Bin.html
'---------------------------------------------------------------------
FUNCTION Bin$ (value&&)
'--- init ---
temp~&& = value&&
Bin$ = STRING$(64, "0"): charPos% = 64: highPos% = 64
'--- convert ---
DO
    IF (temp~&& AND 1) THEN MID$(Bin$, charPos%, 1) = "1": highPos% = charPos%
    charPos% = charPos% - 1: temp~&& = temp~&& \ 2
LOOP UNTIL temp~&& = 0
'--- adjust negative size ---
IF value&& < 0 THEN
    IF -value&& < &H0080000000~&& THEN highPos% = 33
    IF -value&& < &H0000008000~&& THEN highPos% = 49
    IF -value&& < &H0000000080~&& THEN highPos% = 57
END IF
'--- set result ---
Bin$ = MID$(Bin$, highPos%)
END FUNCTION

'--- docs\doc_GuiAppframe.bm\Format.html
'---------------------------------------------------------------------
FUNCTION Format$ (fmt$, arg$, typ%)
shan& = _SOURCE: dhan& = _DEST: than& = _NEWIMAGE(256, 1, 0)
_SOURCE than&: _DEST than&
IF typ% THEN
    PRINT USING fmt$; VAL(arg$);
ELSE
    PRINT USING fmt$; arg$;
END IF
FOR i% = 1 TO POS(0) - 1
    res$ = res$ + CHR$(SCREEN(1, i%))
NEXT i%
_SOURCE shan&: _DEST dhan&: _FREEIMAGE than&
Format$ = res$
END FUNCTION
'-----
FUNCTION Format2$ (fmt$, arg$, typ%, arg2$, typ2%)
shan& = _SOURCE: dhan& = _DEST: than& = _NEWIMAGE(256, 1, 0)
_SOURCE than&: _DEST than&
IF typ% AND typ2% THEN
    PRINT USING fmt$; VAL(arg$); VAL(arg2$);
ELSEIF typ% THEN
    PRINT USING fmt$; VAL(arg$); arg2$;
ELSEIF typ2% THEN
    PRINT USING fmt$; arg$; VAL(arg2$);
ELSE
    PRINT USING fmt$; arg$; arg2$;
END IF
FOR i% = 1 TO POS(0) - 1
    res$ = res$ + CHR$(SCREEN(1, i%))
NEXT i%
_SOURCE shan&: _DEST dhan&: _FREEIMAGE than&
Format2$ = res$
END FUNCTION
'-----
FUNCTION Format3$ (fmt$, arg$, typ%, arg2$, typ2%, arg3$, typ3%)
shan& = _SOURCE: dhan& = _DEST: than& = _NEWIMAGE(256, 1, 0)
_SOURCE than&: _DEST than&
IF typ% AND typ2% AND typ3% THEN
    PRINT USING fmt$; VAL(arg$); VAL(arg2$); VAL(arg3$);
ELSEIF typ% AND typ2% THEN
    PRINT USING fmt$; VAL(arg$); VAL(arg2$); arg3$;
ELSEIF typ% AND typ3% THEN
    PRINT USING fmt$; VAL(arg$); arg2$; VAL(arg3$);
ELSEIF typ2% AND typ3% THEN
    PRINT USING fmt$; arg$; VAL(arg2$); VAL(arg3$);
ELSEIF typ% THEN
    PRINT USING fmt$; VAL(arg$); arg2$; arg3$;
ELSEIF typ2% THEN
    PRINT USING fmt$; arg$; VAL(arg2$); arg3$;
ELSEIF typ3% THEN
    PRINT USING fmt$; arg$; arg2$; VAL(arg3$);
ELSE
    PRINT USING fmt$; arg$; arg2$; arg3$;
END IF
FOR i% = 1 TO POS(0) - 1
    res$ = res$ + CHR$(SCREEN(1, i%))
NEXT i%
_SOURCE shan&: _DEST dhan&: _FREEIMAGE than&
Format3$ = res$
END FUNCTION

'--- docs\doc_GuiAppframe.bm\LRStrip.html
'---------------------------------------------------------------------
FUNCTION LStrip$ (mode%, arg$)
le& = LEN(arg$)
FOR x& = 1 TO le&
    mi% = ASC(arg$, x&)
    IF x& < le& THEN nx% = ASC(UCASE$(MID$(arg$, x& + 1, 1))): ELSE nx% = 0
    SELECT CASE mode%
        CASE stripZERO%
            IF mi% <> 0 THEN EXIT FOR
        CASE stripTAB%
            IF mi% <> 9 THEN EXIT FOR
        CASE stripSPACE%
            IF mi% <> 32 THEN EXIT FOR
        CASE stripQUOTE%
            IF mi% <> 34 THEN EXIT FOR
        CASE stripFIX%
            IF mi% <> 0 AND mi% <> 32 THEN EXIT FOR
        CASE stripWHITE%
            IF mi% <> 9 AND mi% <> 32 THEN EXIT FOR
        CASE stripALL%
            IF mi% <> 0 AND mi% <> 9 AND mi% <> 32 AND mi% <> 34 THEN EXIT FOR
        CASE stripTEXT%
            IF mi% <> 9 AND mi% <> 32 AND mi% <> 34 THEN EXIT FOR
        CASE stripVALUE%
            IF (mi% = 38 AND (nx% = 66 OR nx% = 72 OR nx% = 79)) OR ((mi% = 43 OR mi% = 45) AND (nx% = 46 OR (nx% >= 48 AND nx% <= 57))) OR (mi% = 46 AND (nx% >= 48 AND nx% <= 57)) OR (mi% >= 48 AND mi% <= 57) THEN EXIT FOR
    END SELECT
NEXT x&
LStrip$ = RIGHT$(arg$, LEN(arg$) - x& + 1)
END FUNCTION
'-----
FUNCTION RStrip$ (mode%, arg$)
FOR x& = LEN(arg$) TO 1 STEP -1
    mi% = ASC(arg$, x&)
    SELECT CASE mode%
        CASE stripZERO%
            IF mi% <> 0 THEN EXIT FOR
        CASE stripTAB%
            IF mi% <> 9 THEN EXIT FOR
        CASE stripSPACE%
            IF mi% <> 32 THEN EXIT FOR
        CASE stripQUOTE%
            IF mi% <> 34 THEN EXIT FOR
        CASE stripFIX%
            IF mi% <> 0 AND mi% <> 32 THEN EXIT FOR
        CASE stripWHITE%
            IF mi% <> 9 AND mi% <> 32 THEN EXIT FOR
        CASE stripALL%
            IF mi% <> 0 AND mi% <> 9 AND mi% <> 32 AND mi% <> 34 THEN EXIT FOR
        CASE stripTEXT%
            IF mi% <> 9 AND mi% <> 32 AND mi% <> 34 THEN EXIT FOR
        CASE stripVALUE%
            IF mi% >= 48 AND mi% <= 57 THEN EXIT FOR
    END SELECT
NEXT x&
RStrip$ = LEFT$(arg$, x&)
END FUNCTION

'--- docs\doc_GuiAppframe.bm\RInstr.html
'---------------------------------------------------------------------
FUNCTION RInstr& (start&, source$, find$)
'--- avoid side effect on passed arg ---
iStart& = start&
'--- get string length, set search range ---
sle& = LEN(source$): fle& = LEN(find$): dst& = sle& - fle& + 1 'default start position
IF iStart& = 0 OR iStart& > dst& THEN iStart& = dst&
IF sle& < fle& THEN iStart& = 0
'--- perform search ---
x& = 0
IF fle& > 0 THEN 'avoid a match of "" = ""
    FOR x& = iStart& TO 1 STEP -1
        IF MID$(source$, x&, fle&) = find$ THEN EXIT FOR
    NEXT x&
END IF
'--- return result ---
RInstr& = x&
END FUNCTION

'--- docs\doc_GuiAppframe.bm\ParseLine.html
'---------------------------------------------------------------------
FUNCTION ParseLine& (inpLine$, outArray$(), minUB&)
'--- so far return nothing ---
ParseLine& = -1
'--- init & check some runtime variables ---
ilen& = LEN(inpLine$): icnt& = 1
IF ilen& = 0 THEN EXIT FUNCTION
oalb& = LBOUND(outArray$): oaub& = UBOUND(outArray$): ocnt& = oalb&
'--- skip preceding whitespaces ---
plSkipWhite:
flag% = 0
WHILE icnt& <= ilen& AND NOT flag%
    ch% = ASC(inpLine$, icnt&)
    IF ch% <> 9 AND ch% <> 32 THEN flag% = -1
    icnt& = icnt& + 1
WEND
IF NOT flag% THEN 'nothing else? - then exit
    IF ocnt& > oalb& THEN
        GOTO plEnd
    ELSE
        EXIT FUNCTION
    END IF
END IF
'--- redim to clear array on 1st word/component ---
IF ocnt& = oalb& THEN REDIM outArray$(oalb& TO oaub&)
'--- expand array, if required ---
plNextArg:
IF ocnt& > oaub& THEN
    oaub& = oaub& + 10
    REDIM _PRESERVE outArray$(oalb& TO oaub&)
END IF
'--- get current word/component until next separator ---
flag% = 0: quot% = 0
WHILE icnt& <= ilen& AND NOT flag%
    IF ch% = 34 AND NOT quot% THEN
        quot% = -1
    ELSEIF ch% = 34 AND quot% THEN
        quot% = 0
    END IF
    IF ch% <> 34 THEN outArray$(ocnt&) = outArray$(ocnt&) + CHR$(ch%)
    ch% = ASC(inpLine$, icnt&)
    IF (NOT quot% AND (ch% = 9 OR ch% = 32 OR ch% = 34)) OR (quot% AND ch% = 34) THEN flag% = -1
    icnt& = icnt& + 1
WEND
ocnt& = ocnt& + 1
'--- more words/components following? ---
IF flag% AND ch% = 34 AND NOT quot% AND icnt& <= ilen& GOTO plNextArg
IF flag% THEN
    GOTO plSkipWhite
ELSE
    IF (NOT quot% AND ch% <> 9 AND ch% <> 32 AND ch% <> 34) OR (quot% AND ch% <> 34) THEN
        outArray$(ocnt& - 1) = outArray$(ocnt& - 1) + CHR$(ch%)
    END IF
END IF
'--- final array size adjustment, then exit ---
plEnd:
IF ocnt& - 1 < minUB& THEN ocnt& = minUB& + 1
REDIM _PRESERVE outArray$(oalb& TO (ocnt& - 1))
ParseLine& = ocnt& - 1
END FUNCTION

'--- docs\doc_GuiAppframe.bm\CurrDIR.html
'---------------------------------------------------------------------
FUNCTION CurrDIR$
tmp$ = SPACE$(264)
tle% = GetCurrentDirectoryA&(LEN(tmp$), tmp$)
CurrDIR$ = LEFT$(tmp$, tle%)
END FUNCTION

'---------------------------------------------------------------------
'Function:  Return the path part of the given file specification.
'           Ie. the part upto and incl. the rightmost backslash.
'
'Synopsis:  path$ = PathPart$ (fileSpec$)
'
'Result:    path$ --> depending on fileSpec$:
'                     - the path part incl. the trailing backslash
'                       (regular operation)
'                     - identical to fileSpec$, if it was a path only
'                       (trailing backslash found)
'                     - empty, if it was a file name only (no
'                       backslash found)
'
'Inputs:    fileSpec$ --> the file specification to get the path from,
'                         empty input allowed, results in empty path part
'---------------------------------------------------------------------
FUNCTION PathPart$ (fileSpec$)
PathPart$ = ""
sPo% = RInstr&(0, fileSpec$, "\")
IF sPo% > 0 THEN PathPart$ = LEFT$(fileSpec$, sPo%)
END FUNCTION

'---------------------------------------------------------------------
'Function:  Return the file part of the given file specification.
'           Ie. the part after the rightmost backslash.
'
'Synopsis:  file$ = FilePart$ (fileSpec$)
'
'Result:    file$ --> depending on fileSpec$:
'                     - the file part (regular operation)
'                     - identical to fileSpec$, if it was a file name
'                       only (no backslash found)
'                     - empty, if it was a path only (trailing
'                       backslash found)
'
'Inputs:    fileSpec$ --> the file specification to get the file from,
'                         empty input allowed, results in empty file part
'---------------------------------------------------------------------
FUNCTION FilePart$ (fileSpec$)
FilePart$ = fileSpec$
sPo% = RInstr&(0, fileSpec$, "\")
IF sPo% > 0 THEN FilePart$ = MID$(fileSpec$, sPo% + 1)
END FUNCTION

'---------------------------------------------------------------------
'Function:  Return the name part (without extension) of the given file.
'           Ie. the part left of the rightmost found dot.
'
'Synopsis:  name$ = FileNamePart$ (file$)
'
'Result:    name$ --> depending on file$:
'                     - the file name part (regular operation)
'                     - identical to file$, if it was a file without
'                       extension (no dot found)
'                     - empty, if it was a extension only (leading
'                       dot found)
'
'Inputs:    file$ --> the file to get the file name part from,
'                     empty input allowed, results in empty name part
'
'Notes:     You can pass in a file$ inclusive a path, then the name part
'           returned will contain the same path.
'---------------------------------------------------------------------
FUNCTION FileNamePart$ (file$)
FileNamePart$ = file$
sPo% = RInstr&(0, file$, ".")
IF sPo% > 0 THEN FileNamePart$ = LEFT$(file$, sPo% - 1)
END FUNCTION

'---------------------------------------------------------------------
'Function:  Return the file extension only of the given file.
'           Ie. the part starting with the rightmost found dot.
'
'Synopsis:  ext$ = FileExtension$ (file$)
'
'Result:    ext$ --> depending on file$:
'                    - the file extension incl. dot (regular operation)
'                    - identical to file$, if it was a extension only
'                      (leading dot found)
'                    - empty, if it was a file without extension (no
'                      dot found)
'
'Inputs:    file$ --> the file to get the extension from,
'                     empty input allowed, results in empty extension
'
'Notes:     You can pass in a file$ inclusive a path, it will not
'           affect the result.
'---------------------------------------------------------------------
FUNCTION FileExtension$ (file$)
FileExtension$ = ""
sPo% = RInstr&(0, file$, ".")
IF sPo% > 0 THEN FileExtension$ = MID$(file$, sPo%)
END FUNCTION

'---------------------------------------------------------------------
'Function: Opens a file with next free number and given mode, it will also
'          lock the file according to the given mode. Errors opening the
'          file are ignored and just saved to appLastErr%, you'll get a
'          zero result in such an case and you should decide if you handle
'          the error in place or send it to the global user error handler
'          using the statement ERROR appLastErr%.
'
'Synopsis: fid% = SafeOpenFile% (mode$, file$)
'
'Result:   fid% --> the number of the new opened file or zero on failure
'
'Inputs:   mode$  --> the desired file open mode (INPUT, OUTPUT etc.),
'                     you may abbreviate it, just the 1st letter counts
'          file$  --> the full path/name of the file
'---------------------------------------------------------------------
FUNCTION SafeOpenFile% (mode$, file$)
ff% = FREEFILE
InternalErrHandler
SELECT CASE UCASE$(LEFT$(mode$, 1))
    CASE "A": OPEN file$ FOR APPEND LOCK WRITE AS ff%
    CASE "B": OPEN file$ FOR BINARY LOCK WRITE AS ff%
    CASE "I": OPEN file$ FOR INPUT SHARED AS ff%
    CASE "O": OPEN file$ FOR OUTPUT LOCK WRITE AS ff%
    CASE "R": OPEN file$ FOR RANDOM LOCK WRITE AS ff%
END SELECT
UserErrHandler
IF appLastErr% <> 0 THEN ff% = 0 'if error, then invalidate result
SafeOpenFile% = ff%
END FUNCTION

'---------------------------------------------------------------------
'Function:  Attempt to set the the IFF file pointer to the first found
'           data chunk of the given type.
'
'Synopsis:  ptr& = SeekChunk& (fileNum%, chunkID$)
'
'Result:    ptr&     --> the byte position within the file, where you
'                        find the first chunk of given type, zero if no
'                        chunk of that type is found
'
'Inputs:    fileNum% --> the file ID you got from SafeOpenFile%("B",...)
'           chunkID$ --> the 4 char ID of the wanted chunk (see the TYPE
'                        defines in file GuiAppFrame.bi)
'
'Notes:     In case of failure the file pointer is reset to TOF, in
'           case of success it is set to found byte position.
'---------------------------------------------------------------------
FUNCTION SeekChunk& (fileNum%, chunkID$)
'--- get valid data size from FORM chunk ---
GET fileNum%, 5, vds&: vds& = vds& + chunkSIZEOF%
'--- search given chunk ---
REDIM scChunk(0) AS Chunk
cnt& = 13 'start after FORM....TYPE
WHILE scChunk(0).chunkID <> chunkID$ AND cnt& < vds&
    GET fileNum%, cnt&, scChunk(0)
    cnt& = cnt& + chunkSIZEOF% + scChunk(0).chunkLEN
WEND
IF scChunk(0).chunkID = chunkID$ THEN
    cnt& = cnt& - chunkSIZEOF% - scChunk(0).chunkLEN
    SEEK fileNum%, cnt&
ELSE
    cnt& = 0
    SEEK fileNum%, 1
END IF
ERASE scChunk
'--- return result ---
SeekChunk& = cnt&
END FUNCTION

'---------------------------------------------------------------------
'Function:  Update the FORM-Chunk of an IFF file to new size after adding
'           additional data chunks.
'
'Synopsis:  VOID SizeUpdate (fileNum%, raise&)
'
'Inputs:    fileNum% --> the file ID you got from SafeOpenFile%("B",...)
'           raise&   --> the size of data you added to that file
'
'Notes:     The file pointer is reset to TOF after this routine was called.
'---------------------------------------------------------------------
SUB SizeUpdate (fileNum%, raise&)
'--- update valid data size in FORM chunk ---
GET fileNum%, 5, vds&: vds& = vds& + raise&
PUT fileNum%, 5, vds&: SEEK fileNum%, 1
END SUB

'---------------------------------------------------------------------
'Function: Push the given string argument to the top of stack.
'
'Synopsis: VOID PushStr (arg$)
'
'Inputs:   arg$ --> the STRING argument to push to the stack, use
'                   PushStr(STR$(num)) to pass in a number
'---------------------------------------------------------------------
SUB PushStr (arg$)
ub& = UBOUND(appStackArr$) + 1
REDIM _PRESERVE appStackArr$(ub&)
appStackArr$(ub&) = arg$
END SUB

'---------------------------------------------------------------------
'Function: Get the topmost entry from stack and remove that entry from
'          the stack.
'
'Synopsis: var$ = PopStr$ (VOID)
'
'Result:   var$ --> the entry from stack as type STRING, use VAL(PopStr$)
'                   to get back a number
'
'Notes:    If there are no more entries on the stack (or on the current
'          local stack part), then this function returns an empty string.
'---------------------------------------------------------------------
FUNCTION PopStr$
ub& = UBOUND(appStackArr$)
arg$ = appStackArr$(ub&)
IF arg$ = "*** RhoSigma-Stack-LocalMark ***" OR arg$ = "*** RhoSigma-Stack-Bottom ***" THEN
    PopStr$ = ""
    EXIT FUNCTION
END IF
REDIM _PRESERVE appStackArr$(ub& - 1)
PopStr$ = arg$
END FUNCTION

'---------------------------------------------------------------------
'Function: Init a local stack part in preparation for easy removing of
'          remaining entries.
'
'Synopsis: VOID InitLocalStack (VOID)
'
'Notes:    To properly remove a local stack part a matching subsequent
'          call of SUB RestoreStack is required.
'---------------------------------------------------------------------
SUB InitLocalStack
PushStr "*** RhoSigma-Stack-LocalMark ***"
END SUB

'---------------------------------------------------------------------
'Function: Removes all remaining entries from a local stack part and does
'          erase the local stack part.
'
'Synopsis: VOID RestoreStack (VOID)
'
'Notes:    Don't call this SUB, if there was no local stack part initialized
'          by a previous matching call of SUB InitLocalStack. Otherwise you
'          risk to corrupt the stack.
'---------------------------------------------------------------------
SUB RestoreStack
ub& = UBOUND(appStackArr$)
WHILE appStackArr$(ub&) <> "*** RhoSigma-Stack-LocalMark ***" AND appStackArr$(ub&) <> "*** RhoSigma-Stack-Bottom ***"
    ub& = ub& - 1
WEND
IF appStackArr$(ub&) = "*** RhoSigma-Stack-Bottom ***" THEN EXIT SUB 'a least protect the global stack on unmatched calls
REDIM _PRESERVE appStackArr$(ub& - 1)
END SUB

'---------------------------------------------------------------------
'Opaque fill of the given rectangular area with the given color.
'---------------------------------------------------------------------
'xs%   = left pixel position of the rectangle
'ys%   = top pixel position of the rectangle
'wi%   = pixel width of the rectangle
'he%   = pixel height of the rectangle
'cpen% = color pen for filling
'---------------------------------------------------------------------
SUB FillRectColor (xs%, ys%, wi%, he%, cpen%)
LINE (xs%, ys%)-(xs% + wi% - 1, ys% + he% - 1), cpen%, BF
END SUB

'---------------------------------------------------------------------
'Raster fill of the given rectangular area with the given color. Means
'draw every 2nd pixel with an offset of 1px from line to line. The grid
'is aligned, so that drawing two overlapping rectangles will not lead
'to an opaque filled overlap area.
'---------------------------------------------------------------------
'xs%   = left pixel position of the rectangle
'ys%   = top pixel position of the rectangle
'wi%   = pixel width of the rectangle
'he%   = pixel height of the rectangle
'rpen% = color pen for the drawn raster pixels
'---------------------------------------------------------------------
SUB FillRectRaster (xs%, ys%, wi%, he%, rpen%)
sdot% = &B1010101010101010: sgap% = &B0101010101010101
IF (xs% AND 1) THEN SWAP sdot%, sgap%
IF (ys% AND 1) THEN SWAP sdot%, sgap%
FOR y% = ys% TO ys% + he% - 1
    LINE (xs%, y%)-(xs% + wi% - 1, y%), rpen%, , sdot%
    SWAP sgap%, sdot%
NEXT y%
END SUB

'---------------------------------------------------------------------
'Image fill of the given rectangular area with the given image. The
'given image must not necessarily match the rectangle size, bigger ones
'are cropped, smaller ones will be tiled. Also the image may be flipped
'around its vertical/horizontal axis by specifying a negative size for
'width/height respectively, but note that in those cases the top/left
'positions must mark the respectively opposite side of the fill area.
'---------------------------------------------------------------------
'xs%   = left pixel position of the rectangle
'ys%   = top pixel position of the rectangle
'wi%   = pixel width of the rectangle
'he%   = pixel height of the rectangle
'ihan& = the 8-bit (256 colors) image used for filling
'---------------------------------------------------------------------
SUB FillRectImage (xs%, ys%, wi%, he%, ihan&)
tcol% = _CLEARCOLOR(ihan&): _CLEARCOLOR _NONE, ihan&
than& = _NEWIMAGE(ABS(wi%), ABS(he%), 256)
IF than& < -1 THEN
    FOR y% = 0 TO ABS(he%) - 1 STEP _HEIGHT(ihan&)
        FOR x% = 0 TO ABS(wi%) - 1 STEP _WIDTH(ihan&)
            _PUTIMAGE (x%, y%)-(x% + _WIDTH(ihan&) - 1, y% + _HEIGHT(ihan&) - 1), ihan&, than&
        NEXT x%
    NEXT y%
    IF tcol% > -1 THEN _CLEARCOLOR tcol%, than&
    _PUTIMAGE (xs%, ys%)-(xs% + wi% - 1, ys% + he% - 1), than&
    _FREEIMAGE than&
END IF
END SUB

'---------------------------------------------------------------------
'Function: Will remap the colors of any given image to use the palette
'          of the given 256 colors (8-bit) destination screen, so that it
'          can be displayed on that screen using _PUTIMAGE with as less
'          than possible quality loss. For best results this function does
'          also apply a Floyd-Steinberg error diffusion matrix on the
'          given image to further improve its display quality.
'           The original image is not changed, instead the new remapped
'          image is returned in a new handle, also _SOURCE & _DEST handles
'          are not changed by this function.
'           The algorithm is optimized for speed to the fullest extent
'          possible on the QB64 language level.
'
'Synopsis: rhan& = RemapImageFS& (ohan&, dhan&)
'
'Result:   rhan& --> the handle of the new remapped image, check it for
'                    validity before use (rhan& < -1, as for any other
'                    image handles in QB64)
'
'Inputs:   ohan& --> the handle of the original source image to remap,
'                    may be an image of any color depth (1-32 bits)
'          dhan& --> the handle of the 8-bit destination image, usually
'                    the 256 colors screen the image shall be displayed
'                    on (for the GuiTools Framework this is "appScreen&"),
'                    note that the destinations color palette must already
'                    be setup prior calling this function
'
'Notes:    For the use of this function a globally shared array must be
'          DIMed in an appropriate place: REDIM SHARED fsNearCol%(&HFFFFFF).
'          For the GuiTools Framework this is already done within its init
'          procedure in file GuiAppFrame.bi.
'---------------------------------------------------------------------
FUNCTION RemapImageFS& (ohan&, dhan&)
RemapImageFS& = -1 'so far return invalid handle
shan& = ohan& 'avoid side effect on given argument
IF shan& < -1 THEN
    '--- check/adjust source image & get new 8-bit image ---
    swid% = _WIDTH(shan&): shei% = _HEIGHT(shan&)
    IF _PIXELSIZE(shan&) <> 4 THEN
        than& = _NEWIMAGE(swid%, shei%, 32)
        IF than& >= -1 THEN EXIT FUNCTION
        _PUTIMAGE , shan&, than&
        shan& = than&
    ELSE
        than& = -1 'avoid freeing below
    END IF
    nhan& = _NEWIMAGE(swid%, shei%, 256)
    '--- Floyd-Steinberg error distribution arrays ---
    rhan& = _NEWIMAGE(swid%, 2, 32) 'these are missused as LONG arrays,
    ghan& = _NEWIMAGE(swid%, 2, 32) 'with CHECKING:OFF this is much faster
    bhan& = _NEWIMAGE(swid%, 2, 32) 'than real QB64 arrays
    '--- curr/next row offsets (for distribution array access) ---
    cro% = 0: nro% = swid% * 4 'will be swapped after each pixel row
    '--- the matrix values are extended by 16384 to avoid slow floating ---
    '--- point ops and to allow for integer storage in the above arrays ---
    '--- also it's a power of 2, which may be optimized into a bitshift ---
    seven% = (7 / 16) * 16384 'X+1,Y+0 error fraction
    three% = (3 / 16) * 16384 'X-1,Y+1 error fraction
    five% = (5 / 16) * 16384 'X+0,Y+1 error fraction
    one% = (1 / 16) * 16384 'X+1,Y+1 error fraction
    '--- if all is good, then start remapping ---
    $CHECKING:OFF
    IF nhan& < -1 AND rhan& < -1 AND ghan& < -1 AND bhan& < -1 THEN
        _COPYPALETTE dhan&, nhan& 'dest palette to new image
        '--- for speed we do direct memory access ---
        DIM sbuf AS _MEM: sbuf = _MEMIMAGE(shan&): soff%& = sbuf.OFFSET
        DIM nbuf AS _MEM: nbuf = _MEMIMAGE(nhan&): noff%& = nbuf.OFFSET
        DIM rbuf AS _MEM: rbuf = _MEMIMAGE(rhan&): roff%& = rbuf.OFFSET
        DIM gbuf AS _MEM: gbuf = _MEMIMAGE(ghan&): goff%& = gbuf.OFFSET
        DIM bbuf AS _MEM: bbuf = _MEMIMAGE(bhan&): boff%& = bbuf.OFFSET
        '--- iterate through pixels ---
        FOR y% = 0 TO shei% - 1
            FOR x% = 0 TO swid% - 1
                '--- curr/prev/next pixel offsets ---
                cpo% = x% * 4: ppo% = cpo% - 4: npo% = cpo% + 4
                '--- get pixel ARGB value from source ---
                srgb~& = _MEMGET(sbuf, soff%&, _UNSIGNED LONG)
                '--- add distributed error, shrink by 16384, clear error ---
                '--- current pixel X+0, Y+0 (= cro% (current row offset)) ---
                poff% = cro% + cpo% 'pre-calc full pixel offset
                sr% = ((srgb~& AND &HFF0000~&) \ 65536) + (_MEMGET(rbuf, roff%& + poff%, LONG) \ 16384) 'red
                sg% = ((srgb~& AND &HFF00~&) \ 256) + (_MEMGET(gbuf, goff%& + poff%, LONG) \ 16384) 'green
                sb% = (srgb~& AND &HFF~&) + (_MEMGET(bbuf, boff%& + poff%, LONG) \ 16384) 'blue
                _MEMPUT rbuf, roff%& + poff%, 0 AS LONG 'clearing each single pixel error using _MEMPUT
                _MEMPUT gbuf, goff%& + poff%, 0 AS LONG 'turns out even faster than clearing the entire
                _MEMPUT bbuf, boff%& + poff%, 0 AS LONG 'pixel row using _MEMFILL at the end of the loop
                '--- find nearest color ---
                crgb~& = _RGBA32(sr%, sg%, sb%, 0) 'used for fast value clipping + channel merge
                IF fsNearCol%(crgb~&) > 0 THEN
                    npen% = fsNearCol%(crgb~&) - 1 'already known
                ELSE
                    npen% = FindColor&(sr%, sg%, sb%, nhan&, 24, 255 - guiReservedPens%) 'not known, find one
                    fsNearCol%(crgb~&) = npen% + 1 'save for later use
                END IF
                '--- put colormapped pixel to dest ---
                _MEMPUT nbuf, noff%&, npen% AS _UNSIGNED _BYTE
                '------------------------------------------
                '--- Floyd-Steinberg error distribution ---
                '------------------------------------------
                '--- You may comment this block out, to see the
                '--- result without applied FS matrix.
                '-----
                '--- get dest palette RGB value, calc error to clipped source ---
                nrgb~& = _PALETTECOLOR(npen%, nhan&)
                er% = ((crgb~& AND &HFF0000~&) - (nrgb~& AND &HFF0000~&)) \ 65536
                eg% = ((crgb~& AND &HFF00~&) - (nrgb~& AND &HFF00~&)) \ 256
                eb% = (crgb~& AND &HFF~&) - (nrgb~& AND &HFF~&)
                '--- distribute error according to FS matrix ---
                IF x% > 0 THEN
                    '--- X-1, Y+1 (= nro% (next row offset)) ---
                    poff% = nro% + ppo% 'pre-calc full pixel offset
                    _MEMPUT rbuf, roff%& + poff%, _MEMGET(rbuf, roff%& + poff%, LONG) + (er% * three%) AS LONG 'red
                    _MEMPUT gbuf, goff%& + poff%, _MEMGET(gbuf, goff%& + poff%, LONG) + (eg% * three%) AS LONG 'green
                    _MEMPUT bbuf, boff%& + poff%, _MEMGET(bbuf, boff%& + poff%, LONG) + (eb% * three%) AS LONG 'blue
                END IF
                '--- X+0, Y+1 (= nro% (next row offset)) ---
                poff% = nro% + cpo% 'pre-calc full pixel offset
                _MEMPUT rbuf, roff%& + poff%, _MEMGET(rbuf, roff%& + poff%, LONG) + (er% * five%) AS LONG 'red
                _MEMPUT gbuf, goff%& + poff%, _MEMGET(gbuf, goff%& + poff%, LONG) + (eg% * five%) AS LONG 'green
                _MEMPUT bbuf, boff%& + poff%, _MEMGET(bbuf, boff%& + poff%, LONG) + (eb% * five%) AS LONG 'blue
                IF x% < (swid% - 1) THEN
                    '--- X+1, Y+0 (= cro% (current row offset)) ---
                    poff% = cro% + npo% 'pre-calc full pixel offset
                    _MEMPUT rbuf, roff%& + poff%, _MEMGET(rbuf, roff%& + poff%, LONG) + (er% * seven%) AS LONG 'red
                    _MEMPUT gbuf, goff%& + poff%, _MEMGET(gbuf, goff%& + poff%, LONG) + (eg% * seven%) AS LONG 'green
                    _MEMPUT bbuf, boff%& + poff%, _MEMGET(bbuf, boff%& + poff%, LONG) + (eb% * seven%) AS LONG 'blue
                    '--- X+1, Y+1 (= nro% (next row offset)) ---
                    poff% = nro% + npo% 'pre-calc full pixel offset
                    _MEMPUT rbuf, roff%& + poff%, _MEMGET(rbuf, roff%& + poff%, LONG) + (er% * one%) AS LONG 'red
                    _MEMPUT gbuf, goff%& + poff%, _MEMGET(gbuf, goff%& + poff%, LONG) + (eg% * one%) AS LONG 'green
                    _MEMPUT bbuf, boff%& + poff%, _MEMGET(bbuf, boff%& + poff%, LONG) + (eb% * one%) AS LONG 'blue
                END IF
                '------------------------------------------
                '--- End of FS ----------------------------
                '------------------------------------------
                noff%& = noff%& + 1 'next dest pixel
                soff%& = soff%& + 4 'next source pixel
            NEXT x%
            tmp% = cro%: cro% = nro%: nro% = tmp% 'exchange distribution array row offsets
        NEXT y%
        '--- memory cleanup ---
        _MEMFREE bbuf
        _MEMFREE gbuf
        _MEMFREE rbuf
        _MEMFREE nbuf
        _MEMFREE sbuf
        '--- set result ---
        RemapImageFS& = nhan&
        nhan& = -1 'avoid freeing below
    END IF
    $CHECKING:ON
    '--- remapping done or error, cleanup remains ---
    IF bhan& < -1 THEN _FREEIMAGE bhan&
    IF ghan& < -1 THEN _FREEIMAGE ghan&
    IF rhan& < -1 THEN _FREEIMAGE rhan&
    IF nhan& < -1 THEN _FREEIMAGE nhan&
    IF than& < -1 THEN _FREEIMAGE than&
END IF
END FUNCTION

'****************************************************
'$INCLUDE: 'QB64GuiTools\dev_framework\GuiAppIcon.bm'
'****************************************************

